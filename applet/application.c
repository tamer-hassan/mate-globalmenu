/* application.c generated by valac, the Vala compiler
 * generated from application.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <libwnck/libwnck.h>
#include <gdk-pixbuf/gdk-pixdata.h>
#include <gtk/gtk.h>
#include <mate-menus/matemenu-tree.h>
#include <gio/gio.h>
#include <glib/gi18n-lib.h>
#include <gobject/gvaluecollector.h>


#define TYPE_APPLICATION (application_get_type ())
#define APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_APPLICATION, Application))
#define APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_APPLICATION, ApplicationClass))
#define IS_APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_APPLICATION))
#define IS_APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_APPLICATION))
#define APPLICATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_APPLICATION, ApplicationClass))

typedef struct _Application Application;
typedef struct _ApplicationClass ApplicationClass;
typedef struct _ApplicationPrivate ApplicationPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define __g_list_free_g_object_unref0(var) ((var == NULL) ? NULL : (var = (_g_list_free_g_object_unref (var), NULL)))
#define _matemenu_tree_item_unref0(var) ((var == NULL) ? NULL : (var = (matemenu_tree_item_unref (var), NULL)))
#define _application_unref0(var) ((var == NULL) ? NULL : (var = (application_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
typedef struct _ParamSpecApplication ParamSpecApplication;

struct _Application {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ApplicationPrivate * priv;
	GList* wnck_applications;
};

struct _ApplicationClass {
	GTypeClass parent_class;
	void (*finalize) (Application *self);
};

struct _ApplicationPrivate {
	char* key;
	char* _readable_name;
	char* _exec_path;
	char* _icon_name;
	GdkPixbuf* _icon_pixbuf;
	gboolean _not_in_menu;
	GtkEventBox* _proxy_item;
	GtkLabel* name_widget;
	GtkLabel* status_widget;
	GtkImage* icon_widget;
};

struct _ParamSpecApplication {
	GParamSpec parent_instance;
};


extern GList* application_applications;
GList* application_applications = NULL;
extern GHashTable* application_dict;
GHashTable* application_dict = NULL;
static gboolean application_initialized;
static gboolean application_initialized = FALSE;
static gpointer application_parent_class = NULL;

char* get_task_name_by_pid (gint pid);
gpointer application_ref (gpointer instance);
void application_unref (gpointer instance);
GParamSpec* param_spec_application (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_application (GValue* value, gpointer v_object);
void value_take_application (GValue* value, gpointer v_object);
gpointer value_get_application (const GValue* value);
GType application_get_type (void) G_GNUC_CONST;
#define APPLICATION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_APPLICATION, ApplicationPrivate))
enum  {
	APPLICATION_DUMMY_PROPERTY
};
static void _g_list_free_g_object_unref (GList* self);
static void application_append_node_r (MateMenuTreeDirectory* node);
static void application_application_opened (WnckScreen* s, WnckApplication* wapp);
static void _application_application_opened_wnck_screen_application_opened (WnckScreen* _sender, WnckApplication* app, gpointer self);
static void application_window_opened (WnckScreen* s, WnckWindow* wwin);
static void _application_window_opened_wnck_screen_window_opened (WnckScreen* _sender, WnckWindow* window, gpointer self);
static void application_window_closed (WnckScreen* s, WnckWindow* wwin);
static void _application_window_closed_wnck_screen_window_closed (WnckScreen* _sender, WnckWindow* window, gpointer self);
static void application_application_closed (WnckScreen* s, WnckApplication* wapp);
static void _application_application_closed_wnck_screen_application_closed (WnckScreen* _sender, WnckApplication* app, gpointer self);
void application_init (void);
static Application* application_new (void);
static Application* application_construct (GType object_type);
Application* application_add_application (const char* key);
Application* application_lookup (const char* key);
Application* application_lookup_from_wnck (WnckApplication* wapp);
static char* application_generate_key_from_wnck_window (WnckWindow* win);
static void application_set_not_in_menu (Application* self, gboolean value);
static void application_set_exec_path (Application* self, const char* value);
static void application_set_icon_name (Application* self, const char* value);
static void application_set_readable_name (Application* self, const char* value);
Application* application_lookup_from_wnck_window (WnckWindow* wwin);
static char* application_generate_key_from_wnck (WnckApplication* app);
static void application_set_icon_pixbuf (Application* self, GdkPixbuf* value);
GtkWidget* application_get_proxy_item (Application* self);
const char* application_get_readable_name (Application* self);
const char* application_get_icon_name (Application* self);
void application_update (Application* self);
static char* application_generate_key (MateMenuTreeEntry* entry);
gboolean application_get_not_in_menu (Application* self);
static void application_create_proxy_item (Application* self);
static char* application_get_process_name (gint pid);
const char* application_get_exec_path (Application* self);
GdkPixbuf* application_get_icon_pixbuf (Application* self);
static void application_finalize (Application* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static int _vala_strcmp0 (const char * str1, const char * str2);



static void _g_list_free_g_object_unref (GList* self) {
	g_list_foreach (self, (GFunc) g_object_unref, NULL);
	g_list_free (self);
}


static gpointer _matemenu_tree_item_ref0 (gpointer self) {
	return self ? matemenu_tree_item_ref (self) : NULL;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _application_application_opened_wnck_screen_application_opened (WnckScreen* _sender, WnckApplication* app, gpointer self) {
	application_application_opened (_sender, app);
}


static void _application_window_opened_wnck_screen_window_opened (WnckScreen* _sender, WnckWindow* window, gpointer self) {
	application_window_opened (_sender, window);
}


static void _application_window_closed_wnck_screen_window_closed (WnckScreen* _sender, WnckWindow* window, gpointer self) {
	application_window_closed (_sender, window);
}


static void _application_application_closed_wnck_screen_application_closed (WnckScreen* _sender, WnckApplication* app, gpointer self) {
	application_application_closed (_sender, app);
}


void application_init (void) {
	MateMenuTreeDirectory* node;
	MateMenuTreeDirectory* _tmp0_;
	MateMenuTreeDirectory* _tmp1_;
	WnckScreen* screen;
	GList* list;
	GList* appinfos;
	if (application_initialized) {
		return;
	}
	application_initialized = TRUE;
	node = NULL;
	node = (_tmp0_ = _matemenu_tree_item_ref0 (matemenu_tree_get_root_directory (matemenu_tree_lookup ("applications.menu", MATEMENU_TREE_FLAGS_INCLUDE_EXCLUDED))), _matemenu_tree_item_unref0 (node), _tmp0_);
	application_append_node_r (node);
	node = (_tmp1_ = _matemenu_tree_item_ref0 (matemenu_tree_get_root_directory (matemenu_tree_lookup ("settings.menu", MATEMENU_TREE_FLAGS_INCLUDE_EXCLUDED))), _matemenu_tree_item_unref0 (node), _tmp1_);
	application_append_node_r (node);
	screen = _g_object_ref0 (wnck_screen_get_default ());
	list = wnck_screen_get_windows (screen);
	{
		GList* wwin_collection;
		GList* wwin_it;
		wwin_collection = list;
		for (wwin_it = wwin_collection; wwin_it != NULL; wwin_it = wwin_it->next) {
			WnckWindow* wwin;
			wwin = _g_object_ref0 ((WnckWindow*) wwin_it->data);
			{
				WnckApplication* wapp;
				wapp = _g_object_ref0 (wnck_window_get_application (wwin));
				application_application_opened (screen, wapp);
				_g_object_unref0 (wapp);
				_g_object_unref0 (wwin);
			}
		}
	}
	g_signal_connect (screen, "application-opened", (GCallback) _application_application_opened_wnck_screen_application_opened, NULL);
	g_signal_connect (screen, "window-opened", (GCallback) _application_window_opened_wnck_screen_window_opened, NULL);
	g_signal_connect (screen, "window-closed", (GCallback) _application_window_closed_wnck_screen_window_closed, NULL);
	g_signal_connect (screen, "application-closed", (GCallback) _application_application_closed_wnck_screen_application_closed, NULL);
	appinfos = g_app_info_get_all ();
	{
		GList* appinfo_collection;
		GList* appinfo_it;
		appinfo_collection = appinfos;
		for (appinfo_it = appinfo_collection; appinfo_it != NULL; appinfo_it = appinfo_it->next) {
			GAppInfo* appinfo;
			appinfo = _g_object_ref0 ((GAppInfo*) appinfo_it->data);
			{
				g_debug ("application.vala:88: %s", g_app_info_get_executable (appinfo));
				_g_object_unref0 (appinfo);
			}
		}
	}
	__g_list_free_g_object_unref0 (appinfos);
	_g_object_unref0 (screen);
	_matemenu_tree_item_unref0 (node);
}


static Application* application_construct (GType object_type) {
	Application* self;
	self = (Application*) g_type_create_instance (object_type);
	return self;
}


static Application* application_new (void) {
	return application_construct (TYPE_APPLICATION);
}


Application* application_add_application (const char* key) {
	Application* result = NULL;
	Application* app;
	Application* rt;
	Application* _tmp0_;
	g_return_val_if_fail (key != NULL, NULL);
	app = application_new ();
	rt = app;
	g_hash_table_insert (application_dict, g_strdup (key), app);
	application_applications = g_list_prepend (application_applications, (_tmp0_ = app, app = NULL, _tmp0_));
	result = rt;
	_application_unref0 (app);
	return result;
}


Application* application_lookup (const char* key) {
	Application* result = NULL;
	g_return_val_if_fail (key != NULL, NULL);
	application_init ();
	result = (Application*) g_hash_table_lookup (application_dict, key);
	return result;
}


Application* application_lookup_from_wnck_window (WnckWindow* wwin) {
	Application* result = NULL;
	WnckApplication* wapp;
	Application* rt;
	char* key;
	g_return_val_if_fail (wwin != NULL, NULL);
	application_init ();
	wapp = _g_object_ref0 (wnck_window_get_application (wwin));
	rt = application_lookup_from_wnck (wapp);
	key = application_generate_key_from_wnck_window (wwin);
	if (rt == NULL) {
		g_debug ("application.vala:112: wnck key = %s", key);
		rt = (Application*) g_hash_table_lookup (application_dict, key);
	}
	if (rt == NULL) {
		Application* app;
		char* _tmp0_;
		Application* _tmp1_;
		app = application_new ();
		app->priv->key = (_tmp0_ = g_strdup (key), _g_free0 (app->priv->key), _tmp0_);
		application_set_not_in_menu (app, TRUE);
		application_set_exec_path (app, NULL);
		application_set_icon_name (app, wnck_window_get_icon_name (wwin));
		g_hash_table_insert (application_dict, g_strdup (key), app);
		rt = app;
		application_applications = g_list_prepend (application_applications, (_tmp1_ = app, app = NULL, _tmp1_));
		_application_unref0 (app);
	}
	switch (wnck_window_get_window_type (wwin)) {
		case WNCK_WINDOW_DESKTOP:
		{
			application_set_readable_name (rt, _ ("Desktop"));
			break;
		}
		case WNCK_WINDOW_DOCK:
		{
			application_set_readable_name (rt, "");
			break;
		}
	}
	result = rt;
	_g_free0 (key);
	_g_object_unref0 (wapp);
	return result;
}


Application* application_lookup_from_wnck (WnckApplication* wapp) {
	Application* result = NULL;
	char* key;
	Application* rt;
	g_return_val_if_fail (wapp != NULL, NULL);
	application_init ();
	key = application_generate_key_from_wnck (wapp);
	g_debug ("application.vala:147: wnck key = %s", key);
	rt = (Application*) g_hash_table_lookup (application_dict, key);
	if (rt == NULL) {
		Application* app;
		char* _tmp0_;
		char* name;
		gboolean _tmp1_ = FALSE;
		Application* _tmp3_;
		app = application_new ();
		app->priv->key = (_tmp0_ = g_strdup (key), _g_free0 (app->priv->key), _tmp0_);
		application_set_not_in_menu (app, TRUE);
		name = g_strdup (wnck_application_get_name (wapp));
		if (_vala_strcmp0 (name, ".") == 0) {
			_tmp1_ = TRUE;
		} else {
			_tmp1_ = _vala_strcmp0 (name, "<unknown>") == 0;
		}
		if (_tmp1_) {
			GList* windows;
			windows = wnck_application_get_windows (wapp);
			if (windows != NULL) {
				char* _tmp2_;
				name = (_tmp2_ = g_strdup (wnck_window_get_name ((WnckWindow*) windows->data)), _g_free0 (name), _tmp2_);
			}
		}
		application_set_readable_name (app, name);
		application_set_exec_path (app, NULL);
		application_set_icon_name (app, wnck_application_get_icon_name (wapp));
		g_hash_table_insert (application_dict, g_strdup (key), app);
		rt = app;
		application_applications = g_list_prepend (application_applications, (_tmp3_ = app, app = NULL, _tmp3_));
		_g_free0 (name);
		_application_unref0 (app);
	}
	application_set_icon_pixbuf (rt, wnck_application_get_mini_icon (wapp));
	result = rt;
	_g_free0 (key);
	return result;
}


void application_update (Application* self) {
	g_return_if_fail (self != NULL);
	if (application_get_proxy_item (self) == NULL) {
		return;
	}
	if (self->wnck_applications != NULL) {
		gint n;
		char* _tmp0_;
		n = 0;
		{
			GList* wapp_collection;
			GList* wapp_it;
			wapp_collection = self->wnck_applications;
			for (wapp_it = wapp_collection; wapp_it != NULL; wapp_it = wapp_it->next) {
				WnckApplication* wapp;
				wapp = _g_object_ref0 ((WnckApplication*) wapp_it->data);
				{
					n = n + wnck_application_get_n_windows (wapp);
					_g_object_unref0 (wapp);
				}
			}
		}
		gtk_label_set_label (self->priv->status_widget, _tmp0_ = g_strdup_printf ("%u instances, %d windows", g_list_length (self->wnck_applications), n));
		_g_free0 (_tmp0_);
	} else {
		gtk_label_set_label (self->priv->status_widget, "not launched");
	}
	gtk_label_set_label (self->priv->name_widget, self->priv->_readable_name);
	g_object_set (self->priv->icon_widget, "icon-name", self->priv->_icon_name, NULL);
}


static void application_append_node_r (MateMenuTreeDirectory* node) {
	g_return_if_fail (node != NULL);
	{
		GSList* item_collection;
		GSList* item_it;
		item_collection = matemenu_tree_directory_get_contents (node);
		for (item_it = item_collection; item_it != NULL; item_it = item_it->next) {
			MateMenuTreeItem* item;
			item = _matemenu_tree_item_ref0 ((MateMenuTreeItem*) item_it->data);
			{
				switch (matemenu_tree_item_get_type (item)) {
					case MATEMENU_TREE_ITEM_ENTRY:
					{
						MateMenuTreeEntry* entry;
						char* key;
						Application* app;
						char* _tmp0_;
						Application* _tmp1_;
						entry = _matemenu_tree_item_ref0 ((MateMenuTreeEntry*) item);
						key = application_generate_key (entry);
						g_debug ("application.vala:200: matemenu key = %s", key);
						app = application_new ();
						app->priv->key = (_tmp0_ = g_strdup (key), _g_free0 (app->priv->key), _tmp0_);
						application_set_not_in_menu (app, FALSE);
						application_set_readable_name (app, matemenu_tree_entry_get_name (entry));
						application_set_exec_path (app, matemenu_tree_entry_get_exec (entry));
						application_set_icon_name (app, matemenu_tree_entry_get_icon (entry));
						g_hash_table_insert (application_dict, g_strdup (key), app);
						application_applications = g_list_prepend (application_applications, (_tmp1_ = app, app = NULL, _tmp1_));
						_application_unref0 (app);
						_g_free0 (key);
						_matemenu_tree_item_unref0 (entry);
						break;
					}
					case MATEMENU_TREE_ITEM_DIRECTORY:
					{
						application_append_node_r ((MateMenuTreeDirectory*) item);
						break;
					}
				}
				_matemenu_tree_item_unref0 (item);
			}
		}
	}
}


static gpointer _application_ref0 (gpointer self) {
	return self ? application_ref (self) : NULL;
}


static void application_window_opened (WnckScreen* s, WnckWindow* wwin) {
	Application* app;
	g_return_if_fail (s != NULL);
	g_return_if_fail (wwin != NULL);
	app = _application_ref0 (application_lookup_from_wnck (wnck_window_get_application (wwin)));
	g_object_set_data_full ((GObject*) wwin, "matenu-app", _application_ref0 (app), application_unref);
	application_update (app);
	_application_unref0 (app);
}


static void application_window_closed (WnckScreen* s, WnckWindow* wwin) {
	Application* app;
	g_return_if_fail (s != NULL);
	g_return_if_fail (wwin != NULL);
	app = _application_ref0 ((Application*) g_object_get_data ((GObject*) wwin, "matenu-app"));
	if (app == NULL) {
		_application_unref0 (app);
		return;
	}
	application_update (app);
	_application_unref0 (app);
}


static void application_application_opened (WnckScreen* s, WnckApplication* wapp) {
	Application* app;
	g_return_if_fail (s != NULL);
	g_return_if_fail (wapp != NULL);
	app = _application_ref0 (application_lookup_from_wnck (wapp));
	app->wnck_applications = g_list_prepend (app->wnck_applications, _g_object_ref0 (wapp));
	application_update (app);
	_application_unref0 (app);
}


static void application_application_closed (WnckScreen* s, WnckApplication* wapp) {
	g_return_if_fail (s != NULL);
	g_return_if_fail (wapp != NULL);
	{
		GList* app_collection;
		GList* app_it;
		app_collection = application_applications;
		for (app_it = app_collection; app_it != NULL; app_it = app_it->next) {
			Application* app;
			app = _application_ref0 ((Application*) app_it->data);
			{
				gboolean _tmp0_ = FALSE;
				if (g_list_find (app->wnck_applications, wapp) != NULL) {
					app->wnck_applications = g_list_remove (app->wnck_applications, wapp);
					application_update (app);
				}
				if (app->wnck_applications == NULL) {
					_tmp0_ = app->priv->_not_in_menu;
				} else {
					_tmp0_ = FALSE;
				}
				if (_tmp0_ = TRUE) {
					g_hash_table_remove (application_dict, app->priv->key);
					application_applications = g_list_remove (application_applications, app);
				}
				_application_unref0 (app);
			}
		}
	}
}


static void application_create_proxy_item (Application* self) {
	GtkEventBox* _tmp0_;
	GtkLabel* _tmp1_;
	GtkLabel* _tmp2_;
	GtkImage* _tmp3_;
	GtkHBox* hbox;
	GtkVBox* vbox;
	g_return_if_fail (self != NULL);
	self->priv->_proxy_item = (_tmp0_ = g_object_ref_sink ((GtkEventBox*) gtk_event_box_new ()), _g_object_unref0 (self->priv->_proxy_item), _tmp0_);
	self->priv->name_widget = (_tmp1_ = g_object_ref_sink ((GtkLabel*) gtk_label_new ("")), _g_object_unref0 (self->priv->name_widget), _tmp1_);
	self->priv->status_widget = (_tmp2_ = g_object_ref_sink ((GtkLabel*) gtk_label_new ("")), _g_object_unref0 (self->priv->status_widget), _tmp2_);
	self->priv->icon_widget = (_tmp3_ = g_object_ref_sink ((GtkImage*) gtk_image_new ()), _g_object_unref0 (self->priv->icon_widget), _tmp3_);
	hbox = g_object_ref_sink ((GtkHBox*) gtk_hbox_new (FALSE, 0));
	vbox = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 0));
	gtk_box_pack_start ((GtkBox*) hbox, (GtkWidget*) self->priv->icon_widget, FALSE, FALSE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) hbox, (GtkWidget*) vbox, TRUE, TRUE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) vbox, (GtkWidget*) self->priv->name_widget, FALSE, FALSE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) vbox, (GtkWidget*) self->priv->status_widget, FALSE, FALSE, (guint) 0);
	gtk_container_add ((GtkContainer*) self->priv->_proxy_item, (GtkWidget*) hbox);
	application_update (self);
	_g_object_unref0 (vbox);
	_g_object_unref0 (hbox);
}


static char* application_generate_key_from_wnck (WnckApplication* app) {
	char* result = NULL;
	char* rt;
	g_return_val_if_fail (app != NULL, NULL);
	rt = application_get_process_name (wnck_application_get_pid (app));
	if (rt == NULL) {
		result = g_strdup (wnck_application_get_name (app));
		_g_free0 (rt);
		return result;
	}
	result = rt;
	return result;
}


static char* application_generate_key_from_wnck_window (WnckWindow* win) {
	char* result = NULL;
	char* rt;
	g_return_val_if_fail (win != NULL, NULL);
	rt = application_get_process_name (wnck_window_get_pid (win));
	if (rt == NULL) {
		result = g_strdup (wnck_window_get_name (win));
		_g_free0 (rt);
		return result;
	}
	result = rt;
	return result;
}


static char* application_get_process_name (gint pid) {
	char* result = NULL;
	GError * _inner_error_;
	char* cmdline;
	gint _args_size_;
	gint args_length1;
	char** args;
	gboolean _tmp0_ = FALSE;
	_inner_error_ = NULL;
	cmdline = get_task_name_by_pid (pid);
	args = (args_length1 = 0, NULL);
	if (cmdline == NULL) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = _vala_strcmp0 (cmdline, "") == 0;
	}
	if (_tmp0_) {
		result = NULL;
		args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (cmdline);
		return result;
	}
	{
		char* basename;
		GQuark _tmp2_;
		const char* _tmp1_;
		static GQuark _tmp2__label0 = 0;
		static GQuark _tmp2__label1 = 0;
		static GQuark _tmp2__label2 = 0;
		static GQuark _tmp2__label3 = 0;
		static GQuark _tmp2__label4 = 0;
		g_shell_parse_argv (cmdline, &args_length1, &args, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch0_g_error;
		}
		basename = g_path_get_basename (args[0]);
		_tmp1_ = basename;
		_tmp2_ = (NULL == _tmp1_) ? 0 : g_quark_from_string (_tmp1_);
		if ((((_tmp2_ == ((0 != _tmp2__label0) ? _tmp2__label0 : (_tmp2__label0 = g_quark_from_static_string ("mono")))) || (_tmp2_ == ((0 != _tmp2__label1) ? _tmp2__label1 : (_tmp2__label1 = g_quark_from_static_string ("python"))))) || (_tmp2_ == ((0 != _tmp2__label2) ? _tmp2__label2 : (_tmp2__label2 = g_quark_from_static_string ("python2.5"))))) || (_tmp2_ == ((0 != _tmp2__label3) ? _tmp2__label3 : (_tmp2__label3 = g_quark_from_static_string ("wine")))))
		switch (0) {
			default:
			{
				result = NULL;
				_g_free0 (basename);
				args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
				_g_free0 (cmdline);
				return result;
			}
		} else if (_tmp2_ == ((0 != _tmp2__label4) ? _tmp2__label4 : (_tmp2__label4 = g_quark_from_static_string ("swriter.bin"))))
		switch (0) {
			default:
			{
				result = g_strdup ("openoffice.org");
				_g_free0 (basename);
				args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
				_g_free0 (cmdline);
				return result;
			}
		}
		result = basename;
		args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (cmdline);
		return result;
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			result = NULL;
			_g_error_free0 (e);
			args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
			_g_free0 (cmdline);
			return result;
		}
	}
	__finally0:
	{
		args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (cmdline);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (cmdline);
}


static char* application_generate_key (MateMenuTreeEntry* entry) {
	char* result = NULL;
	GError * _inner_error_;
	gint _args_size_;
	gint args_length1;
	char** args;
	GString* sb;
	gboolean exec;
	g_return_val_if_fail (entry != NULL, NULL);
	_inner_error_ = NULL;
	args = (args_length1 = 0, NULL);
	sb = g_string_new ("");
	exec = TRUE;
	{
		g_shell_parse_argv (matemenu_tree_entry_get_exec (entry), &args_length1, &args, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
		{
			gint i;
			i = 0;
			{
				gboolean _tmp0_;
				_tmp0_ = TRUE;
				while (TRUE) {
					if (!_tmp0_) {
						i++;
					}
					_tmp0_ = FALSE;
					if (!(i < args_length1)) {
						break;
					}
					if (_vala_strcmp0 (args[i], "env") == 0) {
						while (TRUE) {
							if (!(g_utf8_strchr (args[i + 1], (gssize) (-1), (gunichar) '=') != NULL)) {
								break;
							}
							i++;
						}
						continue;
					}
					if (exec) {
						char* basename;
						GQuark _tmp2_;
						const char* _tmp1_;
						static GQuark _tmp2__label0 = 0;
						static GQuark _tmp2__label1 = 0;
						static GQuark _tmp2__label2 = 0;
						static GQuark _tmp2__label3 = 0;
						basename = g_path_get_basename (args[i]);
						_tmp1_ = basename;
						_tmp2_ = (NULL == _tmp1_) ? 0 : g_quark_from_string (_tmp1_);
						if ((((_tmp2_ == ((0 != _tmp2__label0) ? _tmp2__label0 : (_tmp2__label0 = g_quark_from_static_string ("mono")))) || (_tmp2_ == ((0 != _tmp2__label1) ? _tmp2__label1 : (_tmp2__label1 = g_quark_from_static_string ("wine"))))) || (_tmp2_ == ((0 != _tmp2__label2) ? _tmp2__label2 : (_tmp2__label2 = g_quark_from_static_string ("python"))))) || (_tmp2_ == ((0 != _tmp2__label3) ? _tmp2__label3 : (_tmp2__label3 = g_quark_from_static_string ("python2.5")))))
						switch (0) {
							default:
							{
								result = g_strdup (matemenu_tree_entry_get_name (entry));
								_g_free0 (basename);
								_g_string_free0 (sb);
								args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
								return result;
							}
						}
						g_string_append (sb, basename);
						exec = FALSE;
						_g_free0 (basename);
					} else {
					}
				}
			}
		}
		result = g_strdup (sb->str);
		_g_string_free0 (sb);
		args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			result = g_strdup (matemenu_tree_entry_get_exec (entry));
			_g_error_free0 (e);
			_g_string_free0 (sb);
			args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
			return result;
		}
	}
	__finally1:
	{
		_g_string_free0 (sb);
		args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_g_string_free0 (sb);
	args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
}


const char* application_get_readable_name (Application* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_readable_name;
	return result;
}


static void application_set_readable_name (Application* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_readable_name = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_readable_name), _tmp0_);
}


const char* application_get_exec_path (Application* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_exec_path;
	return result;
}


static void application_set_exec_path (Application* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_exec_path = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_exec_path), _tmp0_);
}


const char* application_get_icon_name (Application* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_icon_name;
	return result;
}


static void application_set_icon_name (Application* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_icon_name = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_icon_name), _tmp0_);
}


GdkPixbuf* application_get_icon_pixbuf (Application* self) {
	GdkPixbuf* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_icon_pixbuf;
	return result;
}


static void application_set_icon_pixbuf (Application* self, GdkPixbuf* value) {
	GdkPixbuf* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_icon_pixbuf = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_icon_pixbuf), _tmp0_);
}


gboolean application_get_not_in_menu (Application* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_not_in_menu;
	return result;
}


static void application_set_not_in_menu (Application* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_not_in_menu = value;
}


GtkWidget* application_get_proxy_item (Application* self) {
	GtkWidget* result;
	g_return_val_if_fail (self != NULL, NULL);
	if (self->priv->_proxy_item == NULL) {
		application_create_proxy_item (self);
	}
	result = (GtkWidget*) self->priv->_proxy_item;
	return result;
}


static void value_application_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_application_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		application_unref (value->data[0].v_pointer);
	}
}


static void value_application_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = application_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_application_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_application_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Application* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = application_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_application_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Application** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags && G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = application_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_application (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecApplication* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_APPLICATION), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_application (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_APPLICATION), NULL);
	return value->data[0].v_pointer;
}


void value_set_application (GValue* value, gpointer v_object) {
	Application* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_APPLICATION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_APPLICATION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		application_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		application_unref (old);
	}
}


void value_take_application (GValue* value, gpointer v_object) {
	Application* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_APPLICATION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_APPLICATION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		application_unref (old);
	}
}


static void application_class_init (ApplicationClass * klass) {
	application_parent_class = g_type_class_peek_parent (klass);
	APPLICATION_CLASS (klass)->finalize = application_finalize;
	g_type_class_add_private (klass, sizeof (ApplicationPrivate));
	application_dict = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
}


static void application_instance_init (Application * self) {
	self->priv = APPLICATION_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void application_finalize (Application* obj) {
	Application * self;
	self = APPLICATION (obj);
	_g_free0 (self->priv->key);
	_g_free0 (self->priv->_readable_name);
	_g_free0 (self->priv->_exec_path);
	_g_free0 (self->priv->_icon_name);
	_g_object_unref0 (self->priv->_icon_pixbuf);
	__g_list_free_g_object_unref0 (self->wnck_applications);
	_g_object_unref0 (self->priv->_proxy_item);
	_g_object_unref0 (self->priv->name_widget);
	_g_object_unref0 (self->priv->status_widget);
	_g_object_unref0 (self->priv->icon_widget);
}


GType application_get_type (void) {
	static volatile gsize application_type_id__volatile = 0;
	if (g_once_init_enter (&application_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_application_init, value_application_free_value, value_application_copy_value, value_application_peek_pointer, "p", value_application_collect_value, "p", value_application_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ApplicationClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) application_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Application), 0, (GInstanceInitFunc) application_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType application_type_id;
		application_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Application", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&application_type_id__volatile, application_type_id);
	}
	return application_type_id__volatile;
}


gpointer application_ref (gpointer instance) {
	Application* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void application_unref (gpointer instance) {
	Application* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		APPLICATION_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




