/* switcher.c generated by valac, the Vala compiler
 * generated from switcher.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <globalmenu-server.h>
#include <libwnck/libwnck.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <gdk-pixbuf/gdk-pixdata.h>
#include <glib/gi18n-lib.h>
#include <float.h>
#include <math.h>


#define TYPE_SWITCHER (switcher_get_type ())
#define SWITCHER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SWITCHER, Switcher))
#define SWITCHER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SWITCHER, SwitcherClass))
#define IS_SWITCHER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SWITCHER))
#define IS_SWITCHER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SWITCHER))
#define SWITCHER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SWITCHER, SwitcherClass))

typedef struct _Switcher Switcher;
typedef struct _SwitcherClass SwitcherClass;
typedef struct _SwitcherPrivate SwitcherPrivate;

#define TYPE_SEARCH_BOX_MENU_ITEM (search_box_menu_item_get_type ())
#define SEARCH_BOX_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SEARCH_BOX_MENU_ITEM, SearchBoxMenuItem))
#define SEARCH_BOX_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SEARCH_BOX_MENU_ITEM, SearchBoxMenuItemClass))
#define IS_SEARCH_BOX_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SEARCH_BOX_MENU_ITEM))
#define IS_SEARCH_BOX_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SEARCH_BOX_MENU_ITEM))
#define SEARCH_BOX_MENU_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SEARCH_BOX_MENU_ITEM, SearchBoxMenuItemClass))

typedef struct _SearchBoxMenuItem SearchBoxMenuItem;
typedef struct _SearchBoxMenuItemClass SearchBoxMenuItemClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_WORKSPACE_SELECTOR (workspace_selector_get_type ())
#define WORKSPACE_SELECTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_WORKSPACE_SELECTOR, WorkspaceSelector))
#define WORKSPACE_SELECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_WORKSPACE_SELECTOR, WorkspaceSelectorClass))
#define IS_WORKSPACE_SELECTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_WORKSPACE_SELECTOR))
#define IS_WORKSPACE_SELECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_WORKSPACE_SELECTOR))
#define WORKSPACE_SELECTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_WORKSPACE_SELECTOR, WorkspaceSelectorClass))

typedef struct _WorkspaceSelector WorkspaceSelector;
typedef struct _WorkspaceSelectorClass WorkspaceSelectorClass;

#define TYPE_APPLICATION (application_get_type ())
#define APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_APPLICATION, Application))
#define APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_APPLICATION, ApplicationClass))
#define IS_APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_APPLICATION))
#define IS_APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_APPLICATION))
#define APPLICATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_APPLICATION, ApplicationClass))

typedef struct _Application Application;
typedef struct _ApplicationClass ApplicationClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _application_unref0(var) ((var == NULL) ? NULL : (var = (application_unref (var), NULL)))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define _g_type_class_unref0(var) ((var == NULL) ? NULL : (var = (g_type_class_unref (var), NULL)))
typedef struct _SearchBoxMenuItemPrivate SearchBoxMenuItemPrivate;
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))

struct _Switcher {
	MatenuMenuBar parent_instance;
	SwitcherPrivate * priv;
};

struct _SwitcherClass {
	MatenuMenuBarClass parent_class;
};

struct _SwitcherPrivate {
	char* _label;
	gint _max_size;
	gboolean _show_icon;
	gboolean _show_label;
	gboolean _show_window_list;
	gboolean _enable_search_box;
	gboolean _show_window_actions;
	MatenuMenuItem* _label_item;
	WnckWindow* _current_window;
	char* NOWIN_TEMPLATE;
	char* NOACT_TEMPLATE;
	char* WINACT_TEMPLATE;
	SearchBoxMenuItem* search_box;
	gboolean disposed;
};

struct _SearchBoxMenuItem {
	GtkImageMenuItem parent_instance;
	SearchBoxMenuItemPrivate * priv;
};

struct _SearchBoxMenuItemClass {
	GtkImageMenuItemClass parent_class;
};

struct _SearchBoxMenuItemPrivate {
	GtkEntry* textbox;
};


static gpointer switcher_parent_class = NULL;
static gpointer search_box_menu_item_parent_class = NULL;

gint system (const char* arg);
GType switcher_get_type (void) G_GNUC_CONST;
GType search_box_menu_item_get_type (void) G_GNUC_CONST;
#define SWITCHER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_SWITCHER, SwitcherPrivate))
enum  {
	SWITCHER_DUMMY_PROPERTY,
	SWITCHER_CURRENT_WINDOW,
	SWITCHER_MAX_SIZE,
	SWITCHER_SHOW_ICON,
	SWITCHER_SHOW_LABEL,
	SWITCHER_SHOW_WINDOW_LIST,
	SWITCHER_ENABLE_SEARCH_BOX,
	SWITCHER_SHOW_WINDOW_ACTIONS
};
SearchBoxMenuItem* search_box_menu_item_new (void);
SearchBoxMenuItem* search_box_menu_item_construct (GType object_type);
#define SWITCHER_MENU_TEMPLATE "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" \
"<menu>\n" \
"\t<item id=\"switcher\" underline=\"false\" label=\"%label%\" font=\"b" \
"old\" type=\"%type%\" icon=\"%icon%\">\n" \
"\t\t\t%submenu%\n" \
"\t</item>\n" \
"</menu>"
#define SWITCHER_ITEM_TEMPLATE "<item type=\"image\" id=\"XID%id%\" label=\"%label%\" underline=\"fals" \
"e\" font=\"%font%\" icon=\"pixbuf:%pixdata%\" sensitive=\"true\">%subm" \
"enu%</item>"
Switcher* switcher_new (void);
Switcher* switcher_construct (GType object_type);
void switcher_set_current_window (Switcher* self, WnckWindow* value);
static void switcher_real_dispose (GObject* base);
static void switcher_update (Switcher* self, gboolean include_menu);
static void switcher_on_deactivate (Switcher* self);
static WnckWindow* switcher_item_to_window (Switcher* self, MatenuMenuItem* item);
static gboolean switcher_is_in_sight (Switcher* self, WnckWindow* window);
WorkspaceSelector* workspace_selector_new (WnckWindow* window);
WorkspaceSelector* workspace_selector_construct (GType object_type, WnckWindow* window);
GType workspace_selector_get_type (void) G_GNUC_CONST;
static void switcher_perhaps_minimize_window (Switcher* self, WnckWindow* window);
static void switcher_on_activate (Switcher* self, MatenuShell* _this, MatenuItem* item);
gboolean guess_dock_is_around (void);
static void switcher_set_iconify_destination (Switcher* self, WnckWindow* window);
static char* switcher_do_action_menu (Switcher* self, WnckWindow* window);
char* pixbuf_encode_b64 (GdkPixbuf* pixbuf);
GdkPixbuf* guess_icon (WnckWindow* window, gint width, gint height);
char* template_replace (const char* template, char** subs, int subs_length1);
WnckWindow* find_desktop (void);
static char* switcher_do_xml_menu (Switcher* self);
void search_box_menu_item_set_text (SearchBoxMenuItem* self, const char* value);
WnckWindow* switcher_get_current_window (Switcher* self);
gpointer application_ref (gpointer instance);
void application_unref (gpointer instance);
GParamSpec* param_spec_application (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_application (GValue* value, gpointer v_object);
void value_take_application (GValue* value, gpointer v_object);
gpointer value_get_application (const GValue* value);
GType application_get_type (void) G_GNUC_CONST;
Application* application_lookup_from_wnck_window (WnckWindow* wwin);
const char* application_get_readable_name (Application* self);
char* replace (const char* source, const char* find, const char* replacement);
const char* application_get_icon_name (Application* self);
gboolean application_get_not_in_menu (Application* self);
GdkPixbuf* application_get_icon_pixbuf (Application* self);
static MatenuMenuItem* switcher_window_to_item (Switcher* self, WnckWindow* window);
gint switcher_get_max_size (Switcher* self);
static void switcher_real_size_request (GtkWidget* base, GtkRequisition* req);
void switcher_set_max_size (Switcher* self, gint value);
gboolean switcher_get_show_icon (Switcher* self);
void switcher_set_show_icon (Switcher* self, gboolean value);
gboolean switcher_get_show_label (Switcher* self);
void switcher_set_show_label (Switcher* self, gboolean value);
gboolean switcher_get_show_window_list (Switcher* self);
void switcher_set_show_window_list (Switcher* self, gboolean value);
gboolean switcher_get_enable_search_box (Switcher* self);
void switcher_set_enable_search_box (Switcher* self, gboolean value);
gboolean switcher_get_show_window_actions (Switcher* self);
void switcher_set_show_window_actions (Switcher* self, gboolean value);
static void _switcher_on_activate_matenu_shell_activate (Switcher* _sender, MatenuItem* item, gpointer self);
char* template_replace_simple (const char* template, const char* keyword, const char* value);
static void _switcher_on_deactivate_gtk_menu_shell_deactivate (Switcher* _sender, gpointer self);
static GObject * switcher_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void switcher_finalize (GObject* obj);
static void switcher_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void switcher_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define SEARCH_BOX_MENU_ITEM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_SEARCH_BOX_MENU_ITEM, SearchBoxMenuItemPrivate))
enum  {
	SEARCH_BOX_MENU_ITEM_DUMMY_PROPERTY,
	SEARCH_BOX_MENU_ITEM_TEXT
};
MatenuMenuItem* search_box_menu_item_find_item (SearchBoxMenuItem* self);
static gboolean search_box_menu_item_steal_key_press_event (SearchBoxMenuItem* self, GtkWidget* widget, GdkEventKey* event);
static gboolean _search_box_menu_item_steal_key_press_event_gtk_widget_key_press_event (GtkWidget* _sender, GdkEventKey* event, gpointer self);
static void search_box_menu_item_real_parent_set (GtkWidget* base, GtkWidget* previous_parent);
static void search_box_menu_item_real_activate_item (GtkMenuItem* base);
static void search_box_menu_item_real_activate (GtkMenuItem* base);
const char* search_box_menu_item_get_text (SearchBoxMenuItem* self);
static void _lambda0_ (GtkEntry* box, GtkStateType previous_state, SearchBoxMenuItem* self);
static void __lambda0__gtk_widget_state_changed (GtkEntry* _sender, GtkStateType previous_state, gpointer self);
static void _lambda1_ (GtkEntry* box, SearchBoxMenuItem* self);
static void __lambda1__gtk_editable_changed (GtkEntry* _sender, gpointer self);
static void _lambda2_ (GtkEntry* box, SearchBoxMenuItem* self);
static void __lambda2__gtk_entry_activate (GtkEntry* _sender, gpointer self);
static void _lambda3_ (SearchBoxMenuItem* _this, GtkStateType previous_state, SearchBoxMenuItem* self);
static void __lambda3__gtk_widget_state_changed (SearchBoxMenuItem* _sender, GtkStateType previous_state, gpointer self);
static GObject * search_box_menu_item_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void search_box_menu_item_finalize (GObject* obj);
static void search_box_menu_item_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void search_box_menu_item_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GdkPixbuf* guess_icon_array (GdkPixbuf** icons, int icons_length1, gint width, gint height);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);
static int _vala_strcmp0 (const char * str1, const char * str2);



Switcher* switcher_construct (GType object_type) {
	Switcher * self;
	self = g_object_newv (object_type, 0, NULL);
	return self;
}


Switcher* switcher_new (void) {
	return switcher_construct (TYPE_SWITCHER);
}


static void switcher_real_dispose (GObject* base) {
	Switcher * self;
	self = (Switcher*) base;
	if (!self->priv->disposed) {
		self->priv->disposed = TRUE;
		switcher_set_current_window (self, NULL);
	}
}


static void switcher_on_deactivate (Switcher* self) {
	g_return_if_fail (self != NULL);
	switcher_update (self, FALSE);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void switcher_on_activate (Switcher* self, MatenuShell* _this, MatenuItem* item) {
	MatenuItem* _tmp0_;
	WnckWindow* window;
	GQuark _tmp4_;
	const char* _tmp3_;
	static GQuark _tmp4__label0 = 0;
	static GQuark _tmp4__label1 = 0;
	static GQuark _tmp4__label2 = 0;
	static GQuark _tmp4__label3 = 0;
	static GQuark _tmp4__label4 = 0;
	static GQuark _tmp4__label5 = 0;
	static GQuark _tmp4__label6 = 0;
	static GQuark _tmp4__label7 = 0;
	static GQuark _tmp4__label8 = 0;
	static GQuark _tmp4__label9 = 0;
	static GQuark _tmp4__label10 = 0;
	static GQuark _tmp4__label11 = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (_this != NULL);
	g_return_if_fail (item != NULL);
	if (item == self->priv->_label_item) {
		switcher_update (self, TRUE);
		return;
	}
	window = switcher_item_to_window (self, (_tmp0_ = item, MATENU_IS_MENU_ITEM (_tmp0_) ? ((MatenuMenuItem*) _tmp0_) : NULL));
	if (window == NULL) {
		MatenuShell* parent_shell;
		MatenuItem* parent_item;
		WnckWindow* _tmp2_;
		MatenuItem* _tmp1_;
		parent_shell = _g_object_ref0 (matenu_item_get_shell (item));
		parent_item = _g_object_ref0 (matenu_shell_get_owner (parent_shell));
		window = (_tmp2_ = switcher_item_to_window (self, (_tmp1_ = parent_item, MATENU_IS_MENU_ITEM (_tmp1_) ? ((MatenuMenuItem*) _tmp1_) : NULL)), _g_object_unref0 (window), _tmp2_);
		_g_object_unref0 (parent_item);
		_g_object_unref0 (parent_shell);
	}
	_tmp3_ = matenu_item_get_item_id (item);
	_tmp4_ = (NULL == _tmp3_) ? 0 : g_quark_from_string (_tmp3_);
	if (_tmp4_ == ((0 != _tmp4__label0) ? _tmp4__label0 : (_tmp4__label0 = g_quark_from_static_string ("minimize"))))
	switch (0) {
		default:
		{
			if (window != NULL) {
				wnck_window_minimize (window);
			}
			break;
		}
	} else if (_tmp4_ == ((0 != _tmp4__label1) ? _tmp4__label1 : (_tmp4__label1 = g_quark_from_static_string ("maximize"))))
	switch (0) {
		default:
		{
			if (window != NULL) {
				wnck_window_maximize (window);
			}
			break;
		}
	} else if (_tmp4_ == ((0 != _tmp4__label2) ? _tmp4__label2 : (_tmp4__label2 = g_quark_from_static_string ("unmaximize"))))
	switch (0) {
		default:
		{
			if (window != NULL) {
				wnck_window_unmaximize (window);
			}
			break;
		}
	} else if (_tmp4_ == ((0 != _tmp4__label3) ? _tmp4__label3 : (_tmp4__label3 = g_quark_from_static_string ("move"))))
	switch (0) {
		default:
		{
			if (window != NULL) {
				wnck_window_keyboard_move (window);
			}
			break;
		}
	} else if (_tmp4_ == ((0 != _tmp4__label4) ? _tmp4__label4 : (_tmp4__label4 = g_quark_from_static_string ("resize"))))
	switch (0) {
		default:
		{
			if (window != NULL) {
				wnck_window_keyboard_size (window);
			}
			break;
		}
	} else if (_tmp4_ == ((0 != _tmp4__label5) ? _tmp4__label5 : (_tmp4__label5 = g_quark_from_static_string ("topmost"))))
	switch (0) {
		default:
		{
			if (window != NULL) {
				wnck_window_make_above (window);
			}
			break;
		}
	} else if (_tmp4_ == ((0 != _tmp4__label6) ? _tmp4__label6 : (_tmp4__label6 = g_quark_from_static_string ("untopmost"))))
	switch (0) {
		default:
		{
			if (window != NULL) {
				wnck_window_unmake_above (window);
			}
			break;
		}
	} else if (_tmp4_ == ((0 != _tmp4__label7) ? _tmp4__label7 : (_tmp4__label7 = g_quark_from_static_string ("stick"))))
	switch (0) {
		default:
		{
			if (window != NULL) {
				wnck_window_stick (window);
			}
			break;
		}
	} else if (_tmp4_ == ((0 != _tmp4__label8) ? _tmp4__label8 : (_tmp4__label8 = g_quark_from_static_string ("unstick"))))
	switch (0) {
		default:
		{
			if (window != NULL) {
				wnck_window_unstick (window);
			}
			break;
		}
	} else if (_tmp4_ == ((0 != _tmp4__label9) ? _tmp4__label9 : (_tmp4__label9 = g_quark_from_static_string ("close"))))
	switch (0) {
		default:
		{
			if (window != NULL) {
				wnck_window_close (window, gtk_get_current_event_time ());
			}
			break;
		}
	} else if (_tmp4_ == ((0 != _tmp4__label10) ? _tmp4__label10 : (_tmp4__label10 = g_quark_from_static_string ("show_desktop"))))
	switch (0) {
		default:
		{
			GList* windows;
			windows = wnck_screen_get_windows (wnck_screen_get_default ());
			{
				GList* w_collection;
				GList* w_it;
				w_collection = windows;
				for (w_it = w_collection; w_it != NULL; w_it = w_it->next) {
					WnckWindow* w;
					w = (WnckWindow*) w_it->data;
					{
						if (switcher_is_in_sight (self, w)) {
							wnck_window_minimize (w);
						}
					}
				}
			}
			break;
		}
	} else if (_tmp4_ == ((0 != _tmp4__label11) ? _tmp4__label11 : (_tmp4__label11 = g_quark_from_static_string ("workspaces"))))
	switch (0) {
		default:
		{
			WorkspaceSelector* ws;
			ws = g_object_ref_sink (workspace_selector_new (window));
			gtk_widget_show ((GtkWidget*) ws);
			_g_object_unref0 (ws);
			break;
		}
	} else
	switch (0) {
		default:
		{
			if (matenu_item_get_has_sub_shell (item)) {
				_g_object_unref0 (window);
				return;
			}
			if (window != NULL) {
				switcher_perhaps_minimize_window (self, window);
			}
			break;
		}
	}
	_g_object_unref0 (window);
}


static void switcher_perhaps_minimize_window (Switcher* self, WnckWindow* window) {
	WnckWorkspace* workspace;
	gboolean _tmp0_ = FALSE;
	WnckScreen* screen;
	gint current_workspace_x;
	gint current_workspace_y;
	gint x = 0;
	gint y = 0;
	gint w = 0;
	gint h = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (window != NULL);
	if (!guess_dock_is_around ()) {
		switcher_set_iconify_destination (self, window);
	}
	workspace = _g_object_ref0 (wnck_window_get_workspace (window));
	if (wnck_window_is_active (window)) {
		_tmp0_ = wnck_window_is_visible_on_workspace (window, workspace);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		wnck_window_minimize (window);
		_g_object_unref0 (workspace);
		return;
	}
	screen = _g_object_ref0 (wnck_window_get_screen (window));
	current_workspace_x = wnck_workspace_get_viewport_x (workspace);
	current_workspace_y = wnck_workspace_get_viewport_y (workspace);
	wnck_window_get_geometry (window, &x, &y, &w, &h);
	wnck_screen_move_viewport (screen, current_workspace_x + x, current_workspace_y + y);
	system ("sleep 0.5");
	wnck_window_unminimize (window, gtk_get_current_event_time ());
	system ("sleep 0.5");
	wnck_window_activate (window, gtk_get_current_event_time ());
	_g_object_unref0 (screen);
	_g_object_unref0 (workspace);
}


static void switcher_set_iconify_destination (Switcher* self, WnckWindow* window) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (window != NULL);
	if (!GTK_WIDGET_REALIZED ((GtkWidget*) self)) {
		return;
	}
	if (wnck_window_get_window_type (window) != WNCK_WINDOW_DESKTOP) {
		gint ax;
		gint ay;
		ax = 0;
		ay = 0;
		gdk_window_get_origin (((GtkWidget*) self)->window, &ax, &ay);
		wnck_window_set_icon_geometry (window, ax, ay, 8, 8);
	}
}


static gboolean switcher_is_in_sight (Switcher* self, WnckWindow* window) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (window != NULL, FALSE);
	if (wnck_window_is_in_viewport (window, wnck_window_get_workspace (self->priv->_current_window))) {
		_tmp1_ = !wnck_window_is_minimized (window);
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		_tmp0_ = !wnck_window_is_skip_pager (window);
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}


static char* switcher_do_xml_menu (Switcher* self) {
	char* result = NULL;
	char* items;
	GList* windows;
	char* _tmp18_;
	char* _tmp19_;
	g_return_val_if_fail (self != NULL, NULL);
	if (!self->priv->_show_window_list) {
		result = g_strdup ("");
		return result;
	}
	items = g_strdup ("");
	windows = wnck_screen_get_windows (wnck_screen_get_default ());
	{
		GList* window_collection;
		GList* window_it;
		window_collection = windows;
		for (window_it = window_collection; window_it != NULL; window_it = window_it->next) {
			WnckWindow* window;
			window = (WnckWindow*) window_it->data;
			{
				if (!wnck_window_is_skip_pager (window)) {
					char* font;
					char* submenu_xml;
					char** _tmp6_;
					gint _substs_size_;
					gint substs_length1;
					char** _tmp4_ = NULL;
					GdkPixbuf* _tmp3_;
					char** _tmp5_;
					char** substs;
					char* item;
					char* _tmp7_;
					font = g_strdup ("");
					submenu_xml = g_strdup ("");
					if (wnck_window_is_active (window)) {
						char* _tmp0_;
						char* _tmp1_;
						font = (_tmp0_ = g_strdup ("bold"), _g_free0 (font), _tmp0_);
						submenu_xml = (_tmp1_ = switcher_do_action_menu (self, window), _g_free0 (submenu_xml), _tmp1_);
					} else {
						if (wnck_window_is_minimized (window)) {
							char* _tmp2_;
							font = (_tmp2_ = g_strdup ("italic"), _g_free0 (font), _tmp2_);
						}
					}
					substs = (_tmp6_ = (_tmp5_ = (_tmp4_ = g_new0 (char*, 10 + 1), _tmp4_[0] = g_strdup ("%label%"), _tmp4_[1] = g_markup_escape_text (wnck_window_get_name (window), -1), _tmp4_[2] = g_strdup ("%font%"), _tmp4_[3] = g_strdup (font), _tmp4_[4] = g_strdup ("%submenu%"), _tmp4_[5] = g_strdup (submenu_xml), _tmp4_[6] = g_strdup ("%pixdata%"), _tmp4_[7] = pixbuf_encode_b64 (_tmp3_ = guess_icon (window, -1, -1)), _tmp4_[8] = g_strdup ("%id%"), _tmp4_[9] = g_strdup_printf ("%lu", wnck_window_get_xid (window)), _tmp4_), _g_object_unref0 (_tmp3_), _tmp5_), substs_length1 = 10, _substs_size_ = substs_length1, _tmp6_);
					item = template_replace (SWITCHER_ITEM_TEMPLATE, substs, substs_length1);
					items = (_tmp7_ = g_strconcat (items, item, NULL), _g_free0 (items), _tmp7_);
					_g_free0 (item);
					substs = (_vala_array_free (substs, substs_length1, (GDestroyNotify) g_free), NULL);
					_g_free0 (submenu_xml);
					_g_free0 (font);
				}
			}
		}
	}
	if (_vala_strcmp0 (items, "") == 0) {
		char* _tmp8_;
		items = (_tmp8_ = g_strdup (self->priv->NOWIN_TEMPLATE), _g_free0 (items), _tmp8_);
	} else {
		if (wnck_window_get_window_type (self->priv->_current_window) != WNCK_WINDOW_DESKTOP) {
			char* _tmp9_;
			char* _tmp17_;
			char* _tmp16_;
			char* _tmp15_;
			char* _tmp14_;
			char* _tmp13_;
			char* _tmp12_;
			GdkPixbuf* _tmp11_;
			WnckWindow* _tmp10_;
			items = (_tmp9_ = g_strconcat (items, "<item id=\"separator3\" type=\"separator\"/>", NULL), _g_free0 (items), _tmp9_);
			items = (_tmp17_ = g_strconcat (items, _tmp16_ = g_strconcat (_tmp15_ = g_strconcat (_tmp14_ = g_strconcat (_tmp13_ = g_strconcat ("<item id=\"show_desktop\" type=\"image\" icon=\"pixbuf:", _tmp12_ = pixbuf_encode_b64 (_tmp11_ = guess_icon (_tmp10_ = find_desktop (), -1, -1)), NULL), "\" label=\"", NULL), _ ("Show _Desktop"), NULL), "\"/>", NULL), NULL), _g_free0 (items), _tmp17_);
			_g_free0 (_tmp16_);
			_g_free0 (_tmp15_);
			_g_free0 (_tmp14_);
			_g_free0 (_tmp13_);
			_g_free0 (_tmp12_);
			_g_object_unref0 (_tmp11_);
			_g_object_unref0 (_tmp10_);
		}
	}
	result = (_tmp19_ = g_strconcat (_tmp18_ = g_strconcat ("<menu>", items, NULL), "</menu>", NULL), _g_free0 (_tmp18_), _tmp19_);
	_g_free0 (items);
	return result;
	_g_free0 (items);
}


static char* bool_to_string (gboolean self) {
	char* result = NULL;
	if (self) {
		result = g_strdup ("true");
		return result;
	} else {
		result = g_strdup ("false");
		return result;
	}
}


static char* switcher_do_action_menu (Switcher* self, WnckWindow* window) {
	char* result = NULL;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	char** _tmp7_;
	gint _substs_size_;
	gint substs_length1;
	char** _tmp6_ = NULL;
	char** substs;
	g_return_val_if_fail (self != NULL, NULL);
	if (wnck_window_get_window_type (window) == WNCK_WINDOW_DESKTOP) {
		char* _tmp0_;
		char* _tmp1_;
		result = (_tmp1_ = g_strconcat (_tmp0_ = g_strconcat ("<menu>", self->priv->NOACT_TEMPLATE, NULL), "</menu>", NULL), _g_free0 (_tmp0_), _tmp1_);
		return result;
	}
	if ((wnck_window_get_actions (window) & WNCK_WINDOW_ACTION_MAXIMIZE) != 0) {
		_tmp2_ = !wnck_window_is_maximized (window);
	} else {
		_tmp2_ = FALSE;
	}
	if ((wnck_window_get_actions (window) & WNCK_WINDOW_ACTION_MAXIMIZE) != 0) {
		_tmp3_ = wnck_window_is_maximized (window);
	} else {
		_tmp3_ = FALSE;
	}
	if ((wnck_window_get_actions (window) & WNCK_WINDOW_ACTION_ABOVE) != 0) {
		_tmp4_ = wnck_window_is_above (window);
	} else {
		_tmp4_ = FALSE;
	}
	if ((wnck_window_get_actions (window) & WNCK_WINDOW_ACTION_ABOVE) != 0) {
		_tmp5_ = !wnck_window_is_above (window);
	} else {
		_tmp5_ = FALSE;
	}
	substs = (_tmp7_ = (_tmp6_ = g_new0 (char*, 24 + 1), _tmp6_[0] = g_strdup ("%visibleminimize%"), _tmp6_[1] = bool_to_string ((wnck_window_get_actions (window) & WNCK_WINDOW_ACTION_MINIMIZE) != 0), _tmp6_[2] = g_strdup ("%visiblemaximize%"), _tmp6_[3] = bool_to_string (_tmp2_), _tmp6_[4] = g_strdup ("%visibleunmaximize%"), _tmp6_[5] = bool_to_string (_tmp3_), _tmp6_[6] = g_strdup ("%visiblemove%"), _tmp6_[7] = bool_to_string ((wnck_window_get_actions (window) & WNCK_WINDOW_ACTION_MOVE) != 0), _tmp6_[8] = g_strdup ("%visibleresize"), _tmp6_[9] = bool_to_string ((wnck_window_get_actions (window) & WNCK_WINDOW_ACTION_RESIZE) != 0), _tmp6_[10] = g_strdup ("%visibleseparator1%"), _tmp6_[11] = bool_to_string ((wnck_window_get_actions (window) & WNCK_WINDOW_ACTION_ABOVE) != 0), _tmp6_[12] = g_strdup ("%visibleuntopmost%"), _tmp6_[13] = bool_to_string (_tmp4_), _tmp6_[14] = g_strdup ("%visibletopmost%"), _tmp6_[15] = bool_to_string (_tmp5_), _tmp6_[16] = g_strdup ("%visibleunstick%"), _tmp6_[17] = bool_to_string (wnck_window_is_sticky (window)), _tmp6_[18] = g_strdup ("%visiblestick%"), _tmp6_[19] = bool_to_string (!wnck_window_is_sticky (window)), _tmp6_[20] = g_strdup ("%visibleseparator2%"), _tmp6_[21] = bool_to_string ((wnck_window_get_actions (window) & WNCK_WINDOW_ACTION_CLOSE) != 0), _tmp6_[22] = g_strdup ("%visibleclose%"), _tmp6_[23] = bool_to_string ((wnck_window_get_actions (window) & WNCK_WINDOW_ACTION_CLOSE) != 0), _tmp6_), substs_length1 = 24, _substs_size_ = substs_length1, _tmp7_);
	result = template_replace (self->priv->WINACT_TEMPLATE, substs, substs_length1);
	substs = (_vala_array_free (substs, substs_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static gpointer _application_ref0 (gpointer self) {
	return self ? application_ref (self) : NULL;
}


static void switcher_update (Switcher* self, gboolean include_menu) {
	GError * _inner_error_;
	Application* app;
	char* _tmp0_;
	char* s;
	char* _tmp2_;
	char* _tmp1_;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	search_box_menu_item_set_text (self->priv->search_box, "");
	gtk_widget_set_visible ((GtkWidget*) self, self->priv->_show_icon | self->priv->_show_label);
	if (!gtk_widget_get_visible ((GtkWidget*) self)) {
		return;
	}
	if (switcher_get_current_window (self) == NULL) {
		return;
	}
	if (!guess_dock_is_around ()) {
		switcher_set_iconify_destination (self, self->priv->_current_window);
	}
	app = _application_ref0 (application_lookup_from_wnck_window (switcher_get_current_window (self)));
	self->priv->_label = (_tmp0_ = g_strdup (application_get_readable_name (app)), _g_free0 (self->priv->_label), _tmp0_);
	s = g_strdup (SWITCHER_MENU_TEMPLATE);
	s = (_tmp2_ = replace (s, "%label%", _tmp1_ = g_markup_escape_text (self->priv->_label, -1)), _g_free0 (s), _tmp2_);
	_g_free0 (_tmp1_);
	if (self->priv->_show_icon) {
		gint width;
		gint height;
		char* _tmp5_;
		if (self->priv->_show_label) {
			char* _tmp3_;
			s = (_tmp3_ = replace (s, "%type%", "image"), _g_free0 (s), _tmp3_);
		} else {
			char* _tmp4_;
			s = (_tmp4_ = replace (s, "%type%", "icon"), _g_free0 (s), _tmp4_);
		}
		width = ((GtkWidget*) self)->allocation.width - 2;
		height = ((GtkWidget*) self)->allocation.height - 2;
		if (width <= 0) {
			width = -1;
		}
		if (height <= 0) {
			height = -1;
		}
		g_debug ("switcher.vala:306: iconname = %s no_in_menu = %s", application_get_icon_name (app), _tmp5_ = bool_to_string (application_get_not_in_menu (app)));
		_g_free0 (_tmp5_);
		if (application_get_icon_pixbuf (app) != NULL) {
			char* _tmp8_;
			char* _tmp7_;
			char* _tmp6_;
			s = (_tmp8_ = replace (s, "%icon%", _tmp7_ = g_strconcat ("pixbuf:", _tmp6_ = pixbuf_encode_b64 (application_get_icon_pixbuf (app)), NULL)), _g_free0 (s), _tmp8_);
			_g_free0 (_tmp7_);
			_g_free0 (_tmp6_);
		} else {
			char* _tmp10_;
			char* _tmp9_;
			s = (_tmp10_ = replace (s, "%icon%", _tmp9_ = g_strconcat ("theme:", application_get_icon_name (app), NULL)), _g_free0 (s), _tmp10_);
			_g_free0 (_tmp9_);
		}
	} else {
		char* _tmp11_;
		char* _tmp12_;
		s = (_tmp11_ = replace (s, "%type%", "normal"), _g_free0 (s), _tmp11_);
		s = (_tmp12_ = replace (s, "icon=\"%icon%\"", ""), _g_free0 (s), _tmp12_);
	}
	if (include_menu) {
		if (self->priv->_show_window_list) {
			char* _tmp14_;
			char* _tmp13_;
			GtkMenu* menu;
			s = (_tmp14_ = replace (s, "%submenu%", _tmp13_ = switcher_do_xml_menu (self)), _g_free0 (s), _tmp14_);
			_g_free0 (_tmp13_);
			{
				matenu_parser_parse ((MatenuShell*) self, s, &_inner_error_);
				if (_inner_error_ != NULL) {
					goto __catch25_g_error;
				}
			}
			goto __finally25;
			__catch25_g_error:
			{
				GError * e;
				e = _inner_error_;
				_inner_error_ = NULL;
				{
					_g_error_free0 (e);
				}
			}
			__finally25:
			if (_inner_error_ != NULL) {
				_g_free0 (s);
				_application_unref0 (app);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			menu = _g_object_ref0 (gtk_menu_item_get_submenu ((GtkMenuItem*) self->priv->_label_item));
			{
				GList* widget_collection;
				GList* widget_it;
				widget_collection = gtk_container_get_children ((GtkContainer*) menu);
				for (widget_it = widget_collection; widget_it != NULL; widget_it = widget_it->next) {
					GtkWidget* widget;
					widget = _g_object_ref0 ((GtkWidget*) widget_it->data);
					{
						GtkWidget* _tmp15_;
						MatenuMenuItem* item;
						WnckWindow* window;
						item = _g_object_ref0 ((_tmp15_ = widget, MATENU_IS_MENU_ITEM (_tmp15_) ? ((MatenuMenuItem*) _tmp15_) : NULL));
						if (item == NULL) {
							_g_object_unref0 (item);
							_g_object_unref0 (widget);
							continue;
						}
						matenu_menu_item_set_max_width_chars (item, 30);
						window = switcher_item_to_window (self, item);
						if (window == NULL) {
							_g_object_unref0 (window);
							_g_object_unref0 (item);
							_g_object_unref0 (widget);
							continue;
						}
						_g_object_unref0 (window);
						_g_object_unref0 (item);
						_g_object_unref0 (widget);
					}
				}
				_g_list_free0 (widget_collection);
			}
			_g_object_unref0 (menu);
		} else {
			if (self->priv->_show_window_actions) {
				char* _tmp17_;
				char* _tmp16_;
				s = (_tmp17_ = replace (s, "%submenu%", _tmp16_ = switcher_do_action_menu (self, self->priv->_current_window)), _g_free0 (s), _tmp17_);
				_g_free0 (_tmp16_);
				{
					matenu_parser_parse ((MatenuShell*) self, s, &_inner_error_);
					if (_inner_error_ != NULL) {
						goto __catch26_g_error;
					}
				}
				goto __finally26;
				__catch26_g_error:
				{
					GError * e;
					e = _inner_error_;
					_inner_error_ = NULL;
					{
						_g_error_free0 (e);
					}
				}
				__finally26:
				if (_inner_error_ != NULL) {
					_g_free0 (s);
					_application_unref0 (app);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		}
	} else {
		char* _tmp18_;
		s = (_tmp18_ = replace (s, "%submenu%", "<menu/>"), _g_free0 (s), _tmp18_);
		{
			matenu_parser_parse ((MatenuShell*) self, s, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch27_g_error;
			}
		}
		goto __finally27;
		__catch27_g_error:
		{
			GError * e;
			e = _inner_error_;
			_inner_error_ = NULL;
			{
				_g_error_free0 (e);
			}
		}
		__finally27:
		if (_inner_error_ != NULL) {
			_g_free0 (s);
			_application_unref0 (app);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_g_free0 (s);
	_application_unref0 (app);
}


static MatenuMenuItem* switcher_window_to_item (Switcher* self, WnckWindow* window) {
	MatenuMenuItem* result = NULL;
	char* _tmp1_;
	char* _tmp0_;
	MatenuMenuItem* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (window != NULL, NULL);
	result = (_tmp2_ = matenu_menu_bar_get ((MatenuMenuBar*) self, _tmp1_ = g_strconcat ("/switcher/XID", _tmp0_ = g_strdup_printf ("%lu", wnck_window_get_xid (window)), NULL)), _g_free0 (_tmp1_), _g_free0 (_tmp0_), _tmp2_);
	return result;
}


static WnckWindow* switcher_item_to_window (Switcher* self, MatenuMenuItem* item) {
	WnckWindow* result = NULL;
	char* id;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (item != NULL, NULL);
	id = g_strdup (matenu_item_get_item_id ((MatenuItem*) item));
	if (g_str_has_prefix (id, "XID")) {
		result = _g_object_ref0 (wnck_window_get (strtoul (g_utf8_offset_to_pointer (id, (glong) 3), NULL, 0)));
		_g_free0 (id);
		return result;
	}
	result = NULL;
	_g_free0 (id);
	return result;
}


static void switcher_real_size_request (GtkWidget* base, GtkRequisition* req) {
	Switcher * self;
	gboolean _tmp0_ = FALSE;
	self = (Switcher*) base;
	GTK_WIDGET_CLASS (switcher_parent_class)->size_request ((GtkWidget*) MATENU_MENU_BAR (self), req);
	if (switcher_get_max_size (self) > 0) {
		_tmp0_ = (*req).width > switcher_get_max_size (self);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		(*req).width = switcher_get_max_size (self);
	}
}


WnckWindow* switcher_get_current_window (Switcher* self) {
	WnckWindow* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_current_window;
	return result;
}


void switcher_set_current_window (Switcher* self, WnckWindow* value) {
	WnckWindow* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_current_window = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_current_window), _tmp0_);
	switcher_update (self, TRUE);
	g_object_notify ((GObject *) self, "current-window");
}


gint switcher_get_max_size (Switcher* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_max_size;
	return result;
}


void switcher_set_max_size (Switcher* self, gint value) {
	g_return_if_fail (self != NULL);
	if (self->priv->_max_size == value) {
		return;
	}
	self->priv->_max_size = value;
	if (self->priv->_max_size < 40) {
		self->priv->_max_size = -1;
	}
	switcher_update (self, TRUE);
	g_object_notify ((GObject *) self, "max-size");
}


gboolean switcher_get_show_icon (Switcher* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_show_icon;
	return result;
}


void switcher_set_show_icon (Switcher* self, gboolean value) {
	g_return_if_fail (self != NULL);
	if (self->priv->_show_icon == value) {
		return;
	}
	self->priv->_show_icon = value;
	switcher_update (self, TRUE);
	g_object_notify ((GObject *) self, "show-icon");
}


gboolean switcher_get_show_label (Switcher* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_show_label;
	return result;
}


void switcher_set_show_label (Switcher* self, gboolean value) {
	g_return_if_fail (self != NULL);
	if (self->priv->_show_label == value) {
		return;
	}
	self->priv->_show_label = value;
	switcher_update (self, TRUE);
	g_object_notify ((GObject *) self, "show-label");
}


gboolean switcher_get_show_window_list (Switcher* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_show_window_list;
	return result;
}


void switcher_set_show_window_list (Switcher* self, gboolean value) {
	g_return_if_fail (self != NULL);
	if (self->priv->_show_window_list == value) {
		return;
	}
	self->priv->_show_window_list = value;
	switcher_update (self, TRUE);
	g_object_notify ((GObject *) self, "show-window-list");
}


gboolean switcher_get_enable_search_box (Switcher* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_enable_search_box;
	return result;
}


void switcher_set_enable_search_box (Switcher* self, gboolean value) {
	g_return_if_fail (self != NULL);
	if (self->priv->_enable_search_box == value) {
		return;
	}
	self->priv->_enable_search_box = value;
	switcher_update (self, TRUE);
	gtk_widget_set_visible ((GtkWidget*) self->priv->search_box, self->priv->_enable_search_box);
	g_object_notify ((GObject *) self, "enable-search-box");
}


gboolean switcher_get_show_window_actions (Switcher* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_show_window_actions;
	return result;
}


void switcher_set_show_window_actions (Switcher* self, gboolean value) {
	g_return_if_fail (self != NULL);
	if (self->priv->_show_window_actions == value) {
		return;
	}
	self->priv->_show_window_actions = value;
	switcher_update (self, TRUE);
	g_object_notify ((GObject *) self, "show-window-actions");
}


static void _switcher_on_activate_matenu_shell_activate (Switcher* _sender, MatenuItem* item, gpointer self) {
	switcher_on_activate (self, _sender, item);
}


static void _switcher_on_deactivate_gtk_menu_shell_deactivate (Switcher* _sender, gpointer self) {
	switcher_on_deactivate (self);
}


static GObject * switcher_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	Switcher * self;
	GError * _inner_error_;
	parent_class = G_OBJECT_CLASS (switcher_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = SWITCHER (obj);
	_inner_error_ = NULL;
	{
		char* _tmp3_;
		char* _tmp4_;
		char** _tmp6_;
		gint _substs_size_;
		gint substs_length1;
		char** _tmp5_ = NULL;
		char** substs;
		char* _tmp7_;
		{
			char* s;
			char* _tmp0_;
			MatenuMenuItem* _tmp2_;
			MatenuItem* _tmp1_;
			s = replace (SWITCHER_MENU_TEMPLATE, "%label%", "Global Menu Bar");
			s = (_tmp0_ = replace (s, "%sub-menu%", ""), _g_free0 (s), _tmp0_);
			matenu_parser_parse ((MatenuShell*) self, s, &_inner_error_);
			if (_inner_error_ != NULL) {
				_g_free0 (s);
				goto __catch28_g_error;
			}
			self->priv->_label_item = (_tmp2_ = (_tmp1_ = matenu_shell_get_item ((MatenuShell*) self, 0), MATENU_IS_MENU_ITEM (_tmp1_) ? ((MatenuMenuItem*) _tmp1_) : NULL), _g_object_unref0 (self->priv->_label_item), _tmp2_);
			gtk_menu_shell_append ((GtkMenuShell*) self->priv->_label_item->_submenu_cache, (GtkWidget*) ((GtkMenuItem*) self->priv->search_box));
			g_signal_connect_object ((MatenuShell*) self, "activate", (GCallback) _switcher_on_activate_matenu_shell_activate, self, 0);
			_g_free0 (s);
		}
		goto __finally28;
		__catch28_g_error:
		{
			GError * e;
			e = _inner_error_;
			_inner_error_ = NULL;
			{
				g_warning ("switcher.vala:67: %s", e->message);
				_g_error_free0 (e);
			}
		}
		__finally28:
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
		}
		self->priv->NOWIN_TEMPLATE = (_tmp3_ = template_replace_simple (self->priv->NOWIN_TEMPLATE, "%no_windows%", _ ("no windows")), _g_free0 (self->priv->NOWIN_TEMPLATE), _tmp3_);
		self->priv->NOACT_TEMPLATE = (_tmp4_ = template_replace_simple (self->priv->NOACT_TEMPLATE, "%no_actions%", _ ("no actions")), _g_free0 (self->priv->NOACT_TEMPLATE), _tmp4_);
		substs = (_tmp6_ = (_tmp5_ = g_new0 (char*, 46 + 1), _tmp5_[0] = g_strdup ("%labelminimize%"), _tmp5_[1] = g_strdup (_ ("Mi_nimize")), _tmp5_[2] = g_strdup ("%visiblemaximize%"), _tmp5_[3] = g_strdup ("%visiblemaximize%"), _tmp5_[4] = g_strdup ("%labelmaximize%"), _tmp5_[5] = g_strdup (_ ("Ma_ximize")), _tmp5_[6] = g_strdup ("%visibleminimize%"), _tmp5_[7] = g_strdup ("%visibleminimize%"), _tmp5_[8] = g_strdup ("%labelunmaximize%"), _tmp5_[9] = g_strdup (_ ("Unma_ximize")), _tmp5_[10] = g_strdup ("%visibleunmaximize%"), _tmp5_[11] = g_strdup ("%visibleunmaximize%"), _tmp5_[12] = g_strdup ("%labelmove%"), _tmp5_[13] = g_strdup (_ ("_Move")), _tmp5_[14] = g_strdup ("%visiblemove%"), _tmp5_[15] = g_strdup ("%visiblemove%"), _tmp5_[16] = g_strdup ("%labelresize%"), _tmp5_[17] = g_strdup (_ ("_Resize")), _tmp5_[18] = g_strdup ("%visibleresize"), _tmp5_[19] = g_strdup ("%visibleresize%"), _tmp5_[20] = g_strdup ("%visibleseparator1%"), _tmp5_[21] = g_strdup ("%visibleseparator1%"), _tmp5_[22] = g_strdup ("%labeluntopmost%"), _tmp5_[23] = g_strdup (_ ("Always on _Top")), _tmp5_[24] = g_strdup ("%visibleuntopmost%"), _tmp5_[25] = g_strdup ("%visibleuntopmost%"), _tmp5_[26] = g_strdup ("%labeltopmost%"), _tmp5_[27] = g_strdup (_ ("Always on _Top")), _tmp5_[28] = g_strdup ("%visibletopmost%"), _tmp5_[29] = g_strdup ("%visibletopmost%"), _tmp5_[30] = g_strdup ("%labelunstick%"), _tmp5_[31] = g_strdup (_ ("_Always on visible Workspace")), _tmp5_[32] = g_strdup ("%visibleunstick%"), _tmp5_[33] = g_strdup ("%visibleunstick%"), _tmp5_[34] = g_strdup ("%labelstick%"), _tmp5_[35] = g_strdup (_ ("_Always on visible Workspace")), _tmp5_[36] = g_strdup ("%visiblestick%"), _tmp5_[37] = g_strdup ("%visiblestick%"), _tmp5_[38] = g_strdup ("%labelworkspaces%"), _tmp5_[39] = g_strdup (_ ("_Workspace...")), _tmp5_[40] = g_strdup ("%visibleseparator2%"), _tmp5_[41] = g_strdup ("%visibleseparator2%"), _tmp5_[42] = g_strdup ("%labelclose%"), _tmp5_[43] = g_strdup (_ ("_Close")), _tmp5_[44] = g_strdup ("%visibleclose%"), _tmp5_[45] = g_strdup ("%visibleclose%"), _tmp5_), substs_length1 = 46, _substs_size_ = substs_length1, _tmp6_);
		self->priv->WINACT_TEMPLATE = (_tmp7_ = template_replace (self->priv->WINACT_TEMPLATE, substs, substs_length1), _g_free0 (self->priv->WINACT_TEMPLATE), _tmp7_);
		g_signal_connect_object ((GtkMenuShell*) self, "deactivate", (GCallback) _switcher_on_deactivate_gtk_menu_shell_deactivate, self, 0);
		substs = (_vala_array_free (substs, substs_length1, (GDestroyNotify) g_free), NULL);
	}
	return obj;
}


static void switcher_class_init (SwitcherClass * klass) {
	switcher_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SwitcherPrivate));
	G_OBJECT_CLASS (klass)->dispose = switcher_real_dispose;
	GTK_WIDGET_CLASS (klass)->size_request = switcher_real_size_request;
	G_OBJECT_CLASS (klass)->get_property = switcher_get_property;
	G_OBJECT_CLASS (klass)->set_property = switcher_set_property;
	G_OBJECT_CLASS (klass)->constructor = switcher_constructor;
	G_OBJECT_CLASS (klass)->finalize = switcher_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SWITCHER_CURRENT_WINDOW, g_param_spec_object ("current-window", "current-window", "current-window", WNCK_TYPE_WINDOW, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SWITCHER_MAX_SIZE, g_param_spec_int ("max-size", "max-size", "max-size", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SWITCHER_SHOW_ICON, g_param_spec_boolean ("show-icon", "show-icon", "show-icon", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SWITCHER_SHOW_LABEL, g_param_spec_boolean ("show-label", "show-label", "show-label", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SWITCHER_SHOW_WINDOW_LIST, g_param_spec_boolean ("show-window-list", "show-window-list", "show-window-list", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SWITCHER_ENABLE_SEARCH_BOX, g_param_spec_boolean ("enable-search-box", "enable-search-box", "enable-search-box", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SWITCHER_SHOW_WINDOW_ACTIONS, g_param_spec_boolean ("show-window-actions", "show-window-actions", "show-window-actions", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	{
		GType type;
		GTypeClass* _tmp8_;
		type = WNCK_TYPE_ACTION_MENU;
		_tmp8_ = g_type_class_ref (type);
		_g_type_class_unref0 (_tmp8_);
	}
}


static void switcher_instance_init (Switcher * self) {
	self->priv = SWITCHER_GET_PRIVATE (self);
	self->priv->_max_size = -1;
	self->priv->_show_icon = FALSE;
	self->priv->_show_label = TRUE;
	self->priv->_show_window_list = TRUE;
	self->priv->_enable_search_box = TRUE;
	self->priv->_show_window_actions = TRUE;
	self->priv->NOWIN_TEMPLATE = g_strdup ("<item label=\"%no_windows%\" type=\"image\" icon=\"theme:gtk-about\" s" \
"ensitive=\"false\" font=\"italic\"/>");
	self->priv->NOACT_TEMPLATE = g_strdup ("<item label=\"%no_actions%\" type=\"image\" icon=\"theme:gtk-about\" s" \
"ensitive=\"false\" font=\"italic\"/>");
	self->priv->WINACT_TEMPLATE = g_strdup ("<menu>\n" \
"\t<item id=\"maximize\" type=\"image\" icon=\"wnck-stock-maximize\" la" \
"bel=\"%labelmaximize%\" visible=\"%visiblemaximize%\" />\n" \
"\t<item id=\"minimize\" type=\"image\" icon=\"wnck-stock-minimize\" la" \
"bel=\"%labelminimize%\" visible=\"%visibleminimize%\" />\n" \
"\t<item id=\"unmaximize\" type=\"normal\" label=\"%labelunmaximize%\" " \
"visible=\"%visibleunmaximize%\" />\n" \
"\t<item id=\"move\" type=\"normal\" label=\"%labelmove%\" visible=\"%v" \
"isiblemove%\" />\n" \
"\t<item id=\"resize\" type=\"normal\" label=\"%labelresize%\" visible=" \
"\"%visibleresize%\" />\n" \
"\t<item id=\"separator1\" type=\"separator\" visible=\"%visibleseparat" \
"or1%\" />\n" \
"\t<item id=\"untopmost\" type=\"check\" state=\"toggled\" label=\"%lab" \
"eluntopmost%\" visible=\"%visibleuntopmost%\" />\n" \
"\t<item id=\"topmost\" type=\"check\" state=\"untoggled\" label=\"%lab" \
"eltopmost%\" visible=\"%visibletopmost%\" />\n" \
"\t<item id=\"unstick\" type=\"check\" state=\"toggled\" label=\"%label" \
"unstick%\" visible=\"%visibleunstick%\" />\n" \
"\t<item id=\"stick\" type=\"check\" state=\"untoggled\" label=\"%label" \
"stick%\" visible=\"%visiblestick%\" />\n" \
"\t<item id=\"workspaces\" type=\"normal\" label=\"%labelworkspaces%\" " \
"/>\n" \
"\t<item id=\"separator2\" type=\"separator\" visible=\"%visibleseparat" \
"or2%\" />\n" \
"\t<item id=\"close\" type=\"image\" icon=\"wnck-stock-delete\" label=\"" \
"%labelclose%\" visible=\"%visibleclose%\" />\n" \
"</menu>");
	self->priv->search_box = g_object_ref_sink (search_box_menu_item_new ());
	self->priv->disposed = FALSE;
}


static void switcher_finalize (GObject* obj) {
	Switcher * self;
	self = SWITCHER (obj);
	_g_free0 (self->priv->_label);
	_g_object_unref0 (self->priv->_label_item);
	_g_object_unref0 (self->priv->_current_window);
	_g_free0 (self->priv->NOWIN_TEMPLATE);
	_g_free0 (self->priv->NOACT_TEMPLATE);
	_g_free0 (self->priv->WINACT_TEMPLATE);
	_g_object_unref0 (self->priv->search_box);
	G_OBJECT_CLASS (switcher_parent_class)->finalize (obj);
}


GType switcher_get_type (void) {
	static volatile gsize switcher_type_id__volatile = 0;
	if (g_once_init_enter (&switcher_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SwitcherClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) switcher_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Switcher), 0, (GInstanceInitFunc) switcher_instance_init, NULL };
		GType switcher_type_id;
		switcher_type_id = g_type_register_static (MATENU_TYPE_MENU_BAR, "Switcher", &g_define_type_info, 0);
		g_once_init_leave (&switcher_type_id__volatile, switcher_type_id);
	}
	return switcher_type_id__volatile;
}


static void switcher_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	Switcher * self;
	self = SWITCHER (object);
	switch (property_id) {
		case SWITCHER_CURRENT_WINDOW:
		g_value_set_object (value, switcher_get_current_window (self));
		break;
		case SWITCHER_MAX_SIZE:
		g_value_set_int (value, switcher_get_max_size (self));
		break;
		case SWITCHER_SHOW_ICON:
		g_value_set_boolean (value, switcher_get_show_icon (self));
		break;
		case SWITCHER_SHOW_LABEL:
		g_value_set_boolean (value, switcher_get_show_label (self));
		break;
		case SWITCHER_SHOW_WINDOW_LIST:
		g_value_set_boolean (value, switcher_get_show_window_list (self));
		break;
		case SWITCHER_ENABLE_SEARCH_BOX:
		g_value_set_boolean (value, switcher_get_enable_search_box (self));
		break;
		case SWITCHER_SHOW_WINDOW_ACTIONS:
		g_value_set_boolean (value, switcher_get_show_window_actions (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void switcher_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	Switcher * self;
	self = SWITCHER (object);
	switch (property_id) {
		case SWITCHER_CURRENT_WINDOW:
		switcher_set_current_window (self, g_value_get_object (value));
		break;
		case SWITCHER_MAX_SIZE:
		switcher_set_max_size (self, g_value_get_int (value));
		break;
		case SWITCHER_SHOW_ICON:
		switcher_set_show_icon (self, g_value_get_boolean (value));
		break;
		case SWITCHER_SHOW_LABEL:
		switcher_set_show_label (self, g_value_get_boolean (value));
		break;
		case SWITCHER_SHOW_WINDOW_LIST:
		switcher_set_show_window_list (self, g_value_get_boolean (value));
		break;
		case SWITCHER_ENABLE_SEARCH_BOX:
		switcher_set_enable_search_box (self, g_value_get_boolean (value));
		break;
		case SWITCHER_SHOW_WINDOW_ACTIONS:
		switcher_set_show_window_actions (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


SearchBoxMenuItem* search_box_menu_item_construct (GType object_type) {
	SearchBoxMenuItem * self;
	self = g_object_newv (object_type, 0, NULL);
	return self;
}


SearchBoxMenuItem* search_box_menu_item_new (void) {
	return search_box_menu_item_construct (TYPE_SEARCH_BOX_MENU_ITEM);
}


MatenuMenuItem* search_box_menu_item_find_item (SearchBoxMenuItem* self) {
	MatenuMenuItem* result = NULL;
	GtkContainer* _tmp0_;
	MatenuShell* shell;
	g_return_val_if_fail (self != NULL, NULL);
	shell = _g_object_ref0 ((_tmp0_ = gtk_widget_get_parent ((GtkWidget*) self), MATENU_IS_SHELL (_tmp0_) ? ((MatenuShell*) _tmp0_) : NULL));
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				MatenuItem* _tmp2_;
				MatenuMenuItem* item;
				gboolean _tmp3_ = FALSE;
				if (!_tmp1_) {
					i++;
				}
				_tmp1_ = FALSE;
				if (!(i < matenu_shell_get_length (shell))) {
					break;
				}
				item = (_tmp2_ = matenu_shell_get_item (shell, i), MATENU_IS_MENU_ITEM (_tmp2_) ? ((MatenuMenuItem*) _tmp2_) : NULL);
				if (matenu_item_get_item_label ((MatenuItem*) item) != NULL) {
					char* _tmp5_;
					char* _tmp4_;
					_tmp3_ = g_str_has_prefix (_tmp4_ = g_utf8_casefold (matenu_item_get_item_label ((MatenuItem*) item), -1), _tmp5_ = g_utf8_casefold (gtk_entry_get_text (self->priv->textbox), -1));
					_g_free0 (_tmp5_);
					_g_free0 (_tmp4_);
				} else {
					_tmp3_ = FALSE;
				}
				if (_tmp3_) {
					MatenuMenuItem* _tmp6_;
					result = _g_object_ref0 ((_tmp6_ = item, MATENU_IS_MENU_ITEM (_tmp6_) ? ((MatenuMenuItem*) _tmp6_) : NULL));
					_g_object_unref0 (item);
					_g_object_unref0 (shell);
					return result;
				}
				_g_object_unref0 (item);
			}
		}
	}
	result = NULL;
	_g_object_unref0 (shell);
	return result;
}


static gboolean _search_box_menu_item_steal_key_press_event_gtk_widget_key_press_event (GtkWidget* _sender, GdkEventKey* event, gpointer self) {
	gboolean result;
	result = search_box_menu_item_steal_key_press_event (self, _sender, event);
	return result;
}


static void search_box_menu_item_real_parent_set (GtkWidget* base, GtkWidget* previous_parent) {
	SearchBoxMenuItem * self;
	self = (SearchBoxMenuItem*) base;
	if (previous_parent != NULL) {
		guint _tmp0_;
		g_signal_parse_name ("key-press-event", GTK_TYPE_WIDGET, &_tmp0_, NULL, FALSE);
		g_signal_handlers_disconnect_matched (previous_parent, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp0_, 0, NULL, (GCallback) _search_box_menu_item_steal_key_press_event_gtk_widget_key_press_event, self);
	}
	GTK_WIDGET_CLASS (search_box_menu_item_parent_class)->parent_set ((GtkWidget*) GTK_IMAGE_MENU_ITEM (self), previous_parent);
	if (gtk_widget_get_parent ((GtkWidget*) self) != NULL) {
		g_signal_connect_object ((GtkWidget*) gtk_widget_get_parent ((GtkWidget*) self), "key-press-event", (GCallback) _search_box_menu_item_steal_key_press_event_gtk_widget_key_press_event, self, 0);
	}
}


static gboolean search_box_menu_item_steal_key_press_event (SearchBoxMenuItem* self, GtkWidget* widget, GdkEventKey* event) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (widget != NULL, FALSE);
	result = (g_signal_emit_by_name ((GtkWidget*) self->priv->textbox, "key-press-event", event, &_tmp0_), _tmp0_);
	return result;
}


static void search_box_menu_item_real_activate_item (GtkMenuItem* base) {
	SearchBoxMenuItem * self;
	self = (SearchBoxMenuItem*) base;
}


static void search_box_menu_item_real_activate (GtkMenuItem* base) {
	SearchBoxMenuItem * self;
	self = (SearchBoxMenuItem*) base;
}


const char* search_box_menu_item_get_text (SearchBoxMenuItem* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = gtk_entry_get_text (self->priv->textbox);
	return result;
}


void search_box_menu_item_set_text (SearchBoxMenuItem* self, const char* value) {
	g_return_if_fail (self != NULL);
	gtk_entry_set_text (self->priv->textbox, value);
	g_object_notify ((GObject *) self, "text");
}


static void _lambda0_ (GtkEntry* box, GtkStateType previous_state, SearchBoxMenuItem* self) {
	g_return_if_fail (box != NULL);
	((GtkWidget*) self->priv->textbox)->state = (guchar) GTK_STATE_NORMAL;
}


static void __lambda0__gtk_widget_state_changed (GtkEntry* _sender, GtkStateType previous_state, gpointer self) {
	_lambda0_ (_sender, previous_state, self);
}


static void _lambda1_ (GtkEntry* box, SearchBoxMenuItem* self) {
	GtkContainer* _tmp0_;
	MatenuMenu* shell;
	MatenuMenuItem* item;
	g_return_if_fail (box != NULL);
	shell = _g_object_ref0 ((_tmp0_ = gtk_widget_get_parent ((GtkWidget*) self), MATENU_IS_MENU (_tmp0_) ? ((MatenuMenu*) _tmp0_) : NULL));
	item = search_box_menu_item_find_item (self);
	if (item != NULL) {
		gtk_menu_shell_select_item ((GtkMenuShell*) shell, (GtkWidget*) item);
	}
	_g_object_unref0 (item);
	_g_object_unref0 (shell);
}


static void __lambda1__gtk_editable_changed (GtkEntry* _sender, gpointer self) {
	_lambda1_ (_sender, self);
}


static void _lambda2_ (GtkEntry* box, SearchBoxMenuItem* self) {
	GtkContainer* _tmp0_;
	MatenuMenu* shell;
	MatenuMenuItem* item;
	g_return_if_fail (box != NULL);
	shell = _g_object_ref0 ((_tmp0_ = gtk_widget_get_parent ((GtkWidget*) self), MATENU_IS_MENU (_tmp0_) ? ((MatenuMenu*) _tmp0_) : NULL));
	item = search_box_menu_item_find_item (self);
	if (item != NULL) {
		gtk_menu_shell_activate_item ((GtkMenuShell*) shell, (GtkWidget*) item, TRUE);
	}
	_g_object_unref0 (item);
	_g_object_unref0 (shell);
}


static void __lambda2__gtk_entry_activate (GtkEntry* _sender, gpointer self) {
	_lambda2_ (_sender, self);
}


static void _lambda3_ (SearchBoxMenuItem* _this, GtkStateType previous_state, SearchBoxMenuItem* self) {
	g_return_if_fail (_this != NULL);
	((GtkWidget*) self)->state = (guchar) GTK_STATE_NORMAL;
}


static void __lambda3__gtk_widget_state_changed (SearchBoxMenuItem* _sender, GtkStateType previous_state, gpointer self) {
	_lambda3_ (_sender, previous_state, self);
}


static GObject * search_box_menu_item_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	SearchBoxMenuItem * self;
	parent_class = G_OBJECT_CLASS (search_box_menu_item_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = SEARCH_BOX_MENU_ITEM (obj);
	{
		GtkImage* _tmp9_;
		gtk_image_menu_item_set_image ((GtkImageMenuItem*) self, (GtkWidget*) (_tmp9_ = g_object_ref_sink ((GtkImage*) gtk_image_new_from_icon_name ("search", GTK_ICON_SIZE_MENU))));
		_g_object_unref0 (_tmp9_);
		g_object_set (self->priv->textbox, "editable", TRUE, NULL);
		gtk_widget_set_sensitive ((GtkWidget*) self->priv->textbox, TRUE);
		g_object_set ((GtkWidget*) self->priv->textbox, "can-focus", TRUE, NULL);
		gtk_entry_set_text (self->priv->textbox, "Type here...");
		g_object_set ((GtkWidget*) self->priv->textbox, "is-focus", TRUE, NULL);
		gtk_container_add ((GtkContainer*) self, (GtkWidget*) self->priv->textbox);
		gtk_widget_show_all ((GtkWidget*) self);
		gtk_container_set_focus_child ((GtkContainer*) self, (GtkWidget*) self->priv->textbox);
		((GtkWidget*) self->priv->textbox)->state = (guchar) GTK_STATE_NORMAL;
		g_signal_connect_object ((GtkWidget*) self->priv->textbox, "state-changed", (GCallback) __lambda0__gtk_widget_state_changed, self, 0);
		g_signal_connect_object ((GtkEditable*) self->priv->textbox, "changed", (GCallback) __lambda1__gtk_editable_changed, self, 0);
		g_signal_connect_object (self->priv->textbox, "activate", (GCallback) __lambda2__gtk_entry_activate, self, 0);
		g_signal_connect_object ((GtkWidget*) self, "state-changed", (GCallback) __lambda3__gtk_widget_state_changed, self, 0);
	}
	return obj;
}


static void search_box_menu_item_class_init (SearchBoxMenuItemClass * klass) {
	search_box_menu_item_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SearchBoxMenuItemPrivate));
	GTK_WIDGET_CLASS (klass)->parent_set = search_box_menu_item_real_parent_set;
	GTK_MENU_ITEM_CLASS (klass)->activate_item = search_box_menu_item_real_activate_item;
	GTK_MENU_ITEM_CLASS (klass)->activate = search_box_menu_item_real_activate;
	G_OBJECT_CLASS (klass)->get_property = search_box_menu_item_get_property;
	G_OBJECT_CLASS (klass)->set_property = search_box_menu_item_set_property;
	G_OBJECT_CLASS (klass)->constructor = search_box_menu_item_constructor;
	G_OBJECT_CLASS (klass)->finalize = search_box_menu_item_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEARCH_BOX_MENU_ITEM_TEXT, g_param_spec_string ("text", "text", "text", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void search_box_menu_item_instance_init (SearchBoxMenuItem * self) {
	self->priv = SEARCH_BOX_MENU_ITEM_GET_PRIVATE (self);
	self->priv->textbox = g_object_ref_sink ((GtkEntry*) gtk_entry_new ());
}


static void search_box_menu_item_finalize (GObject* obj) {
	SearchBoxMenuItem * self;
	self = SEARCH_BOX_MENU_ITEM (obj);
	_g_object_unref0 (self->priv->textbox);
	G_OBJECT_CLASS (search_box_menu_item_parent_class)->finalize (obj);
}


GType search_box_menu_item_get_type (void) {
	static volatile gsize search_box_menu_item_type_id__volatile = 0;
	if (g_once_init_enter (&search_box_menu_item_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SearchBoxMenuItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) search_box_menu_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SearchBoxMenuItem), 0, (GInstanceInitFunc) search_box_menu_item_instance_init, NULL };
		GType search_box_menu_item_type_id;
		search_box_menu_item_type_id = g_type_register_static (GTK_TYPE_IMAGE_MENU_ITEM, "SearchBoxMenuItem", &g_define_type_info, 0);
		g_once_init_leave (&search_box_menu_item_type_id__volatile, search_box_menu_item_type_id);
	}
	return search_box_menu_item_type_id__volatile;
}


static void search_box_menu_item_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SearchBoxMenuItem * self;
	self = SEARCH_BOX_MENU_ITEM (object);
	switch (property_id) {
		case SEARCH_BOX_MENU_ITEM_TEXT:
		g_value_set_string (value, search_box_menu_item_get_text (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void search_box_menu_item_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	SearchBoxMenuItem * self;
	self = SEARCH_BOX_MENU_ITEM (object);
	switch (property_id) {
		case SEARCH_BOX_MENU_ITEM_TEXT:
		search_box_menu_item_set_text (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


GdkPixbuf* guess_icon (WnckWindow* window, gint width, gint height) {
	GdkPixbuf* result = NULL;
	GdkPixbuf** _tmp1_;
	gint _icons_size_;
	gint icons_length1;
	GdkPixbuf** _tmp0_ = NULL;
	GdkPixbuf** icons;
	g_return_val_if_fail (window != NULL, NULL);
	icons = (_tmp1_ = (_tmp0_ = g_new0 (GdkPixbuf*, 2 + 1), _tmp0_[0] = _g_object_ref0 (wnck_window_get_mini_icon (window)), _tmp0_[1] = _g_object_ref0 (wnck_window_get_icon (window)), _tmp0_), icons_length1 = 2, _icons_size_ = icons_length1, _tmp1_);
	result = guess_icon_array (icons, icons_length1, width, height);
	icons = (_vala_array_free (icons, icons_length1, (GDestroyNotify) g_object_unref), NULL);
	return result;
}


GdkPixbuf* guess_icon_array (GdkPixbuf** icons, int icons_length1, gint width, gint height) {
	GdkPixbuf* result = NULL;
	GdkPixbuf* icon;
	gint min_dist;
	gint best_size;
	gboolean _tmp0_ = FALSE;
	gint scaled_size;
	double ratio;
	gint scaled_width;
	gint scaled_height;
	GdkPixbuf* scaled_icon;
	icon = NULL;
	min_dist = 99999;
	best_size = 16;
	if (height == (-1)) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = width == (-1);
	}
	if (_tmp0_) {
		gtk_icon_size_lookup (GTK_ICON_SIZE_MENU, &width, &height);
	}
	scaled_size = height;
	if (width < scaled_size) {
		scaled_size = width;
	}
	{
		GdkPixbuf** i_collection;
		int i_collection_length1;
		int i_it;
		i_collection = icons;
		i_collection_length1 = icons_length1;
		for (i_it = 0; i_it < icons_length1; i_it = i_it + 1) {
			GdkPixbuf* i;
			i = _g_object_ref0 (i_collection[i_it]);
			{
				gint size;
				gint dist;
				size = gdk_pixbuf_get_height (i);
				if (gdk_pixbuf_get_width (i) > size) {
					size = gdk_pixbuf_get_width (i);
				}
				dist = size - scaled_size;
				if (dist < 0) {
					dist = -dist;
				}
				if (dist < min_dist) {
					GdkPixbuf* _tmp1_;
					min_dist = dist;
					icon = (_tmp1_ = _g_object_ref0 (i), _g_object_unref0 (icon), _tmp1_);
					best_size = size;
				}
				_g_object_unref0 (i);
			}
		}
	}
	if (icon == NULL) {
		result = _g_object_ref0 (icons[0]);
		_g_object_unref0 (icon);
		return result;
	}
	ratio = ((double) scaled_size) / ((double) best_size);
	if (ratio < 0) {
		ratio = 1.0;
	}
	scaled_width = (gint) (gdk_pixbuf_get_width (icon) * ratio);
	scaled_height = (gint) (gdk_pixbuf_get_height (icon) * ratio);
	scaled_icon = gdk_pixbuf_new (GDK_COLORSPACE_RGB, gdk_pixbuf_get_has_alpha (icon), 8, scaled_width, scaled_height);
	gdk_pixbuf_scale (icon, scaled_icon, 0, 0, gdk_pixbuf_get_width (scaled_icon), gdk_pixbuf_get_height (scaled_icon), (double) 0, (double) 0, ratio, ratio, GDK_INTERP_BILINEAR);
	result = scaled_icon;
	_g_object_unref0 (icon);
	return result;
}


gboolean guess_dock_is_around (void) {
	gboolean result = FALSE;
	GList* windows;
	windows = wnck_screen_get_windows (wnck_screen_get_default ());
	{
		GList* window_collection;
		GList* window_it;
		window_collection = windows;
		for (window_it = window_collection; window_it != NULL; window_it = window_it->next) {
			WnckWindow* window;
			window = (WnckWindow*) window_it->data;
			{
				if (wnck_window_get_window_type (window) == WNCK_WINDOW_DOCK) {
					GQuark _tmp1_;
					const char* _tmp0_;
					static GQuark _tmp1__label0 = 0;
					static GQuark _tmp1__label1 = 0;
					static GQuark _tmp1__label2 = 0;
					_tmp0_ = wnck_application_get_name (wnck_window_get_application (window));
					_tmp1_ = (NULL == _tmp0_) ? 0 : g_quark_from_string (_tmp0_);
					if (((_tmp1_ == ((0 != _tmp1__label0) ? _tmp1__label0 : (_tmp1__label0 = g_quark_from_static_string ("cairo-dock")))) || (_tmp1_ == ((0 != _tmp1__label1) ? _tmp1__label1 : (_tmp1__label1 = g_quark_from_static_string ("avant-window-navigator"))))) || (_tmp1_ == ((0 != _tmp1__label2) ? _tmp1__label2 : (_tmp1__label2 = g_quark_from_static_string ("Do")))))
					switch (0) {
						default:
						{
							result = TRUE;
							return result;
						}
					}
				}
			}
		}
	}
	result = FALSE;
	return result;
}


WnckWindow* find_desktop (void) {
	WnckWindow* result = NULL;
	GList* windows;
	windows = wnck_screen_get_windows (wnck_screen_get_default ());
	{
		GList* window_collection;
		GList* window_it;
		window_collection = windows;
		for (window_it = window_collection; window_it != NULL; window_it = window_it->next) {
			WnckWindow* window;
			window = (WnckWindow*) window_it->data;
			{
				if (wnck_window_get_window_type (window) == WNCK_WINDOW_DESKTOP) {
					result = _g_object_ref0 (window);
					return result;
				}
			}
		}
	}
	result = NULL;
	return result;
}


char* replace (const char* source, const char* find, const char* replacement) {
	char* result = NULL;
	char** _tmp1_;
	gint _buf_size_;
	gint buf_length1;
	char** _tmp0_;
	char** buf;
	GString* sb;
	g_return_val_if_fail (source != NULL, NULL);
	g_return_val_if_fail (find != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	buf = (_tmp1_ = _tmp0_ = g_strsplit (source, find, 0), buf_length1 = _vala_array_length (_tmp0_), _buf_size_ = buf_length1, _tmp1_);
	sb = g_string_new ("");
	{
		gint co;
		co = 0;
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				if (!_tmp2_) {
					co++;
				}
				_tmp2_ = FALSE;
				if (!(co < buf_length1)) {
					break;
				}
				g_string_append (sb, buf[co]);
				if (co != (buf_length1 - 1)) {
					g_string_append (sb, replacement);
				}
			}
		}
	}
	result = g_strdup (sb->str);
	_g_string_free0 (sb);
	buf = (_vala_array_free (buf, buf_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


char* pixbuf_encode_b64 (GdkPixbuf* pixbuf) {
	char* result = NULL;
	GdkPixdata _tmp0_ = {0};
	GdkPixdata pixdata;
	guchar* _tmp3_;
	gint _tmp2__length1;
	guchar* _tmp2_;
	gint _tmp1_;
	char* _tmp4_;
	g_return_val_if_fail (pixbuf != NULL, NULL);
	pixdata = (_tmp0_.magic = (guint32) 0, _tmp0_);
	gdk_pixdata_from_pixbuf (&pixdata, pixbuf, TRUE);
	result = (_tmp4_ = (_tmp3_ = (_tmp2_ = gdk_pixdata_serialize (&pixdata, &_tmp1_), _tmp2__length1 = _tmp1_, _tmp2_), g_base64_encode (_tmp3_, _tmp1_)), _tmp2_ = (g_free (_tmp2_), NULL), _tmp4_);
	return result;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




