/* globalmenu-settings.c generated by valac, the Vala compiler
 * generated from globalmenu-settings.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <globalmenu-settings.h>
#include <glib/gi18n-lib.h>
#include <configmake.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <stdio.h>

#define _g_type_class_unref0(var) ((var == NULL) ? NULL : (var = (g_type_class_unref (var), NULL)))
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))


extern char** pairs;
extern gint pairs_length1;
char** pairs = NULL;
gint pairs_length1 = 0;
static gint _pairs_size_ = 0;
extern gboolean show;
gboolean show = FALSE;
extern GObjectClass* klass;
GObjectClass* klass = NULL;
extern MatenuSettings* settings;
MatenuSettings* settings = NULL;
extern gulong xid;
gulong xid = (gulong) 0;

void list_settings (void);
void set_key (const char* key, const char* v);
gint _vala_main (char** args, int args_length1);
static int _vala_strcmp0 (const char * str1, const char * str2);

const GOptionEntry options[4] = {{"show", 's', 0, G_OPTION_ARG_NONE, &show, N_ ("Show current settings"), NULL}, {"window", 'w', 0, G_OPTION_ARG_INT, &xid, N_ ("Access local settings of the window(XWin ID)"), NULL}, {"", (gchar) 0, 0, G_OPTION_ARG_STRING_ARRAY, &pairs, N_ ("key/setting pairs"), "[ key settings ] ..."}, {NULL}};


gint _vala_main (char** args, int args_length1) {
	gint result = 0;
	GError * _inner_error_;
	GObjectClass* _tmp0_;
	GOptionContext* context;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	_inner_error_ = NULL;
	bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
	textdomain (GETTEXT_PACKAGE);
	klass = (_tmp0_ = (GObjectClass*) g_type_class_ref (MATENU_TYPE_SETTINGS), _g_type_class_unref0 (klass), _tmp0_);
	context = g_option_context_new (" -- Modify Global Menu Settings");
	g_option_context_set_description (context, N_ ("A tool to modify Global Menu settings."));
	g_option_context_set_help_enabled (context, TRUE);
	g_option_context_add_group (context, gtk_get_option_group (TRUE));
	g_option_context_add_main_entries (context, options, NULL);
	g_option_context_parse (context, &args_length1, &args, &_inner_error_);
	if (_inner_error_ != NULL) {
		_g_option_context_free0 (context);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	if (xid == 0) {
		MatenuSettings* _tmp1_;
		settings = (_tmp1_ = (MatenuSettings*) matenu_global_settings_get (gdk_screen_get_default ()), _g_object_unref0 (settings), _tmp1_);
	} else {
		MatenuSettings* _tmp2_;
		settings = (_tmp2_ = (MatenuSettings*) matenu_local_settings_new (gdk_window_foreign_new ((GdkNativeWindow) xid)), _g_object_unref0 (settings), _tmp2_);
	}
	if (show) {
		list_settings ();
		result = 0;
		_g_option_context_free0 (context);
		return result;
	}
	if (pairs == NULL) {
		_tmp4_ = TRUE;
	} else {
		_tmp4_ = (pairs_length1 = (gint) g_strv_length (pairs)) == 0;
	}
	if (_tmp4_) {
		_tmp3_ = TRUE;
	} else {
		_tmp3_ = (pairs_length1 % 2) != 0;
	}
	if (_tmp3_) {
		char* _tmp5_;
		fprintf (stdout, "%s\n", _tmp5_ = g_option_context_get_help (context, FALSE, NULL));
		_g_free0 (_tmp5_);
		result = 0;
		_g_option_context_free0 (context);
		return result;
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp6_;
			_tmp6_ = TRUE;
			while (TRUE) {
				if (!_tmp6_) {
					i = i + 2;
				}
				_tmp6_ = FALSE;
				if (!(i < pairs_length1)) {
					break;
				}
				set_key (pairs[i], pairs[i + 1]);
			}
		}
	}
	matenu_settings_push (settings);
	gdk_flush ();
	result = 0;
	_g_option_context_free0 (context);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return _vala_main (argv, argc);
}


void list_settings (void) {
	{
		const char** key_collection;
		int key_collection_length1;
		int key_it;
		key_collection = MATENU_SETTINGS_KEYS;
		key_collection_length1 = G_N_ELEMENTS (MATENU_SETTINGS_KEYS);
		for (key_it = 0; key_it < G_N_ELEMENTS (MATENU_SETTINGS_KEYS); key_it = key_it + 1) {
			const char* key;
			key = key_collection[key_it];
			{
				GParamSpec* ps;
				GValue value = {0};
				char* _tmp0_;
				ps = g_object_class_find_property (klass, key);
				g_value_init (&value, ps->value_type);
				g_object_get_property ((GObject*) settings, ps->name, &value);
				fprintf (stdout, "%s (%s) = %s\n", ps->name, g_type_name (ps->value_type), _tmp0_ = g_strdup_value_contents (&value));
				_g_free0 (_tmp0_);
				G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
			}
		}
	}
}


static gboolean string_to_bool (const char* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (_vala_strcmp0 (self, "true") == 0) {
		result = TRUE;
		return result;
	} else {
		result = FALSE;
		return result;
	}
}


void set_key (const char* key, const char* v) {
	GParamSpec* pspec;
	GValue value = {0};
	g_return_if_fail (key != NULL);
	g_return_if_fail (v != NULL);
	pspec = g_object_class_find_property (klass, key);
	if (pspec == NULL) {
		fprintf (stdout, "key `%s' is not supported.\n", key);
		return;
	}
	g_value_init (&value, pspec->value_type);
	if (pspec->value_type == G_TYPE_BOOLEAN) {
		g_value_set_boolean (&value, string_to_bool (v));
	} else {
		if (pspec->value_type == G_TYPE_STRING) {
			g_value_set_string (&value, v);
		} else {
			if (pspec->value_type == G_TYPE_INT) {
				g_value_set_int (&value, atoi (v));
			} else {
				fprintf (stdout, "unsupported value type `%s'.\n", g_type_name (pspec->value_type));
				G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
				return;
			}
		}
	}
	g_object_set_property ((GObject*) settings, key, &value);
	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




